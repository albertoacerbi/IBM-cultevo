<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Chapter 14 Social network structure | Individual-based models of cultural evolution</title>
  <meta name="description" content="Chapter 14 Social network structure | Individual-based models of cultural evolution" />
  <meta name="generator" content="bookdown 0.21.4 and GitBook 2.6.7" />

  <meta property="og:title" content="Chapter 14 Social network structure | Individual-based models of cultural evolution" />
  <meta property="og:type" content="book" />
  
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Chapter 14 Social network structure | Individual-based models of cultural evolution" />
  
  
  

<meta name="author" content="Alberto Acerbi" />
<meta name="author" content="Marco Smolla" />
<meta name="author" content="Alex Mesoudi" />


<meta name="date" content="2020-11-30" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="demography.html"/>
<link rel="next" href="group-structured-populations-and-migration.html"/>
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />









<script src="libs/accessible-code-block-0.0.1/empty-anchor.js"></script>
<link href="libs/anchor-sections-1.0.1/anchor-sections.css" rel="stylesheet" />
<script src="libs/anchor-sections-1.0.1/anchor-sections.js"></script>


<style type="text/css">
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Individual-based models of cultural evolution</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Introduction</a><ul>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#aim-of-the-book"><i class="fa fa-check"></i>Aim of the book</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#what-is-cultural-evolution"><i class="fa fa-check"></i>What is cultural evolution?</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#why-model"><i class="fa fa-check"></i>Why model?</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#why-individual-based-models"><i class="fa fa-check"></i>Why individual-based models?</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#how-to-use-this-book---the-programming"><i class="fa fa-check"></i>How to use this book - the programming</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#how-to-use-this-book---the-simulations"><i class="fa fa-check"></i>How to use this book - the simulations</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#conventions-and-formatting"><i class="fa fa-check"></i>Conventions and formatting</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#further-reading"><i class="fa fa-check"></i>Further reading</a></li>
</ul></li>
<li class="part"><span><b>Basics</b></span></li>
<li class="chapter" data-level="1" data-path="unbiased-transmission.html"><a href="unbiased-transmission.html"><i class="fa fa-check"></i><b>1</b> Unbiased transmission</a><ul>
<li class="chapter" data-level="1.1" data-path="unbiased-transmission.html"><a href="unbiased-transmission.html#initialising-the-simulation"><i class="fa fa-check"></i><b>1.1</b> Initialising the simulation</a></li>
<li class="chapter" data-level="1.2" data-path="unbiased-transmission.html"><a href="unbiased-transmission.html#execute-generation-turn-over-many-times"><i class="fa fa-check"></i><b>1.2</b> Execute generation turn-over many times</a></li>
<li class="chapter" data-level="1.3" data-path="unbiased-transmission.html"><a href="unbiased-transmission.html#plotting-the-model-results"><i class="fa fa-check"></i><b>1.3</b> Plotting the model results</a></li>
<li class="chapter" data-level="1.4" data-path="unbiased-transmission.html"><a href="unbiased-transmission.html#write-a-function-to-wrap-the-model-code"><i class="fa fa-check"></i><b>1.4</b> Write a function to wrap the model code</a></li>
<li class="chapter" data-level="1.5" data-path="unbiased-transmission.html"><a href="unbiased-transmission.html#run-several-independent-simulations-and-plot-their-results"><i class="fa fa-check"></i><b>1.5</b> Run several independent simulations and plot their results</a></li>
<li class="chapter" data-level="1.6" data-path="unbiased-transmission.html"><a href="unbiased-transmission.html#varying-initial-conditions"><i class="fa fa-check"></i><b>1.6</b> Varying initial conditions</a></li>
<li class="chapter" data-level="1.7" data-path="unbiased-transmission.html"><a href="unbiased-transmission.html#summary-of-the-model"><i class="fa fa-check"></i><b>1.7</b> Summary of the model</a></li>
<li class="chapter" data-level="1.8" data-path="unbiased-transmission.html"><a href="unbiased-transmission.html#further-reading-1"><i class="fa fa-check"></i><b>1.8</b> Further reading</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="unbiased-and-biased-mutation.html"><a href="unbiased-and-biased-mutation.html"><i class="fa fa-check"></i><b>2</b> Unbiased and biased mutation</a><ul>
<li class="chapter" data-level="2.1" data-path="unbiased-and-biased-mutation.html"><a href="unbiased-and-biased-mutation.html#unbiased-mutation"><i class="fa fa-check"></i><b>2.1</b> Unbiased mutation</a></li>
<li class="chapter" data-level="2.2" data-path="unbiased-and-biased-mutation.html"><a href="unbiased-and-biased-mutation.html#biased-mutation"><i class="fa fa-check"></i><b>2.2</b> Biased mutation</a></li>
<li class="chapter" data-level="2.3" data-path="unbiased-and-biased-mutation.html"><a href="unbiased-and-biased-mutation.html#summary-of-the-model-1"><i class="fa fa-check"></i><b>2.3</b> Summary of the model</a></li>
<li class="chapter" data-level="2.4" data-path="unbiased-and-biased-mutation.html"><a href="unbiased-and-biased-mutation.html#further-reading-2"><i class="fa fa-check"></i><b>2.4</b> Further reading</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="biased-transmission-direct-bias.html"><a href="biased-transmission-direct-bias.html"><i class="fa fa-check"></i><b>3</b> Biased transmission: direct bias</a><ul>
<li class="chapter" data-level="3.1" data-path="biased-transmission-direct-bias.html"><a href="biased-transmission-direct-bias.html#a-simple-model-of-directly-biased-transmission"><i class="fa fa-check"></i><b>3.1</b> A simple model of directly biased transmission</a></li>
<li class="chapter" data-level="3.2" data-path="biased-transmission-direct-bias.html"><a href="biased-transmission-direct-bias.html#strength-of-selection"><i class="fa fa-check"></i><b>3.2</b> Strength of selection</a></li>
<li class="chapter" data-level="3.3" data-path="biased-transmission-direct-bias.html"><a href="biased-transmission-direct-bias.html#summary-of-the-model-2"><i class="fa fa-check"></i><b>3.3</b> Summary of the model</a></li>
<li class="chapter" data-level="3.4" data-path="biased-transmission-direct-bias.html"><a href="biased-transmission-direct-bias.html#further-reading-3"><i class="fa fa-check"></i><b>3.4</b> Further reading</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="biased-transmission-frequency-dependent-indirect-bias.html"><a href="biased-transmission-frequency-dependent-indirect-bias.html"><i class="fa fa-check"></i><b>4</b> Biased transmission: frequency-dependent indirect bias</a><ul>
<li class="chapter" data-level="4.1" data-path="biased-transmission-frequency-dependent-indirect-bias.html"><a href="biased-transmission-frequency-dependent-indirect-bias.html#the-logic-of-conformity"><i class="fa fa-check"></i><b>4.1</b> The logic of conformity</a></li>
<li class="chapter" data-level="4.2" data-path="biased-transmission-frequency-dependent-indirect-bias.html"><a href="biased-transmission-frequency-dependent-indirect-bias.html#testing-conformist-transmission"><i class="fa fa-check"></i><b>4.2</b> Testing conformist transmission</a></li>
<li class="chapter" data-level="4.3" data-path="biased-transmission-frequency-dependent-indirect-bias.html"><a href="biased-transmission-frequency-dependent-indirect-bias.html#summary-of-the-model-3"><i class="fa fa-check"></i><b>4.3</b> Summary of the model</a></li>
<li class="chapter" data-level="4.4" data-path="biased-transmission-frequency-dependent-indirect-bias.html"><a href="biased-transmission-frequency-dependent-indirect-bias.html#further-readings"><i class="fa fa-check"></i><b>4.4</b> Further readings</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="biased-transmission-demonstrator-based-indirect-bias.html"><a href="biased-transmission-demonstrator-based-indirect-bias.html"><i class="fa fa-check"></i><b>5</b> Biased transmission: demonstrator-based indirect bias</a><ul>
<li class="chapter" data-level="5.1" data-path="biased-transmission-demonstrator-based-indirect-bias.html"><a href="biased-transmission-demonstrator-based-indirect-bias.html#a-simple-demonstrator-bias"><i class="fa fa-check"></i><b>5.1</b> A simple demonstrator bias</a></li>
<li class="chapter" data-level="5.2" data-path="biased-transmission-demonstrator-based-indirect-bias.html"><a href="biased-transmission-demonstrator-based-indirect-bias.html#predicting-the-winning-trait"><i class="fa fa-check"></i><b>5.2</b> Predicting the ‘winning’ trait</a></li>
<li class="chapter" data-level="5.3" data-path="biased-transmission-demonstrator-based-indirect-bias.html"><a href="biased-transmission-demonstrator-based-indirect-bias.html#summary-of-the-model-4"><i class="fa fa-check"></i><b>5.3</b> Summary of the model</a></li>
<li class="chapter" data-level="5.4" data-path="biased-transmission-demonstrator-based-indirect-bias.html"><a href="biased-transmission-demonstrator-based-indirect-bias.html#further-readings-1"><i class="fa fa-check"></i><b>5.4</b> Further readings</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="vertical-and-horizontal-transmission.html"><a href="vertical-and-horizontal-transmission.html"><i class="fa fa-check"></i><b>6</b> Vertical and horizontal transmission</a><ul>
<li class="chapter" data-level="6.1" data-path="vertical-and-horizontal-transmission.html"><a href="vertical-and-horizontal-transmission.html#vertical-cultural-transmission"><i class="fa fa-check"></i><b>6.1</b> Vertical cultural transmission</a></li>
<li class="chapter" data-level="6.2" data-path="vertical-and-horizontal-transmission.html"><a href="vertical-and-horizontal-transmission.html#horizontal-cultural-transmission"><i class="fa fa-check"></i><b>6.2</b> Horizontal cultural transmission</a></li>
<li class="chapter" data-level="6.3" data-path="vertical-and-horizontal-transmission.html"><a href="vertical-and-horizontal-transmission.html#summary-of-the-model-5"><i class="fa fa-check"></i><b>6.3</b> Summary of the model</a></li>
<li class="chapter" data-level="6.4" data-path="vertical-and-horizontal-transmission.html"><a href="vertical-and-horizontal-transmission.html#further-reading-4"><i class="fa fa-check"></i><b>6.4</b> Further reading</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="multiple-traits-models.html"><a href="multiple-traits-models.html"><i class="fa fa-check"></i><b>7</b> Multiple traits models</a><ul>
<li class="chapter" data-level="7.1" data-path="multiple-traits-models.html"><a href="multiple-traits-models.html#unbiased-transmission-with-multiple-traits"><i class="fa fa-check"></i><b>7.1</b> Unbiased transmission with multiple traits</a></li>
<li class="chapter" data-level="7.2" data-path="multiple-traits-models.html"><a href="multiple-traits-models.html#introducing-innovation"><i class="fa fa-check"></i><b>7.2</b> Introducing innovation</a></li>
<li class="chapter" data-level="7.3" data-path="multiple-traits-models.html"><a href="multiple-traits-models.html#optimising-the-code"><i class="fa fa-check"></i><b>7.3</b> Optimising the code</a></li>
<li class="chapter" data-level="7.4" data-path="multiple-traits-models.html"><a href="multiple-traits-models.html#the-distribution-of-popularity"><i class="fa fa-check"></i><b>7.4</b> The distribution of popularity</a></li>
<li class="chapter" data-level="7.5" data-path="multiple-traits-models.html"><a href="multiple-traits-models.html#summary-of-the-model-6"><i class="fa fa-check"></i><b>7.5</b> Summary of the model</a></li>
<li class="chapter" data-level="7.6" data-path="multiple-traits-models.html"><a href="multiple-traits-models.html#further-readings-2"><i class="fa fa-check"></i><b>7.6</b> Further readings</a></li>
</ul></li>
<li class="part"><span><b>Advanced topics - The evolution of cultural evolution</b></span></li>
<li class="chapter" data-level="8" data-path="rogers-paradox.html"><a href="rogers-paradox.html"><i class="fa fa-check"></i><b>8</b> Rogers’ Paradox</a><ul>
<li class="chapter" data-level="8.1" data-path="rogers-paradox.html"><a href="rogers-paradox.html#modelling-rogers-paradox"><i class="fa fa-check"></i><b>8.1</b> Modelling Rogers’ Paradox</a></li>
<li class="chapter" data-level="8.2" data-path="rogers-paradox.html"><a href="rogers-paradox.html#summary-of-the-model-7"><i class="fa fa-check"></i><b>8.2</b> Summary of the model</a></li>
<li class="chapter" data-level="8.3" data-path="rogers-paradox.html"><a href="rogers-paradox.html#further-reading-5"><i class="fa fa-check"></i><b>8.3</b> Further reading</a></li>
</ul></li>
<li class="chapter" data-level="9" data-path="rogers-paradox-a-solution.html"><a href="rogers-paradox-a-solution.html"><i class="fa fa-check"></i><b>9</b> Rogers’ Paradox: A Solution</a><ul>
<li class="chapter" data-level="9.1" data-path="rogers-paradox-a-solution.html"><a href="rogers-paradox-a-solution.html#modelling-critical-social-learners"><i class="fa fa-check"></i><b>9.1</b> Modelling critical social learners</a></li>
<li class="chapter" data-level="9.2" data-path="rogers-paradox-a-solution.html"><a href="rogers-paradox-a-solution.html#summary-of-the-model-8"><i class="fa fa-check"></i><b>9.2</b> Summary of the model</a></li>
<li class="chapter" data-level="9.3" data-path="rogers-paradox-a-solution.html"><a href="rogers-paradox-a-solution.html#further-reading-6"><i class="fa fa-check"></i><b>9.3</b> Further reading</a></li>
</ul></li>
<li class="part"><span><b>Advanced topics - Cultural inheritance</b></span></li>
<li class="chapter" data-level="10" data-path="reproduction-and-transformation.html"><a href="reproduction-and-transformation.html"><i class="fa fa-check"></i><b>10</b> Reproduction and transformation</a><ul>
<li class="chapter" data-level="10.1" data-path="reproduction-and-transformation.html"><a href="reproduction-and-transformation.html#copying-and-selection"><i class="fa fa-check"></i><b>10.1</b> Copying and selection</a></li>
<li class="chapter" data-level="10.2" data-path="reproduction-and-transformation.html"><a href="reproduction-and-transformation.html#convergent-transformation"><i class="fa fa-check"></i><b>10.2</b> Convergent transformation</a></li>
<li class="chapter" data-level="10.3" data-path="reproduction-and-transformation.html"><a href="reproduction-and-transformation.html#emergent-similarity"><i class="fa fa-check"></i><b>10.3</b> Emergent similarity</a></li>
<li class="chapter" data-level="10.4" data-path="reproduction-and-transformation.html"><a href="reproduction-and-transformation.html#cultural-fitness"><i class="fa fa-check"></i><b>10.4</b> Cultural fitness</a></li>
<li class="chapter" data-level="10.5" data-path="reproduction-and-transformation.html"><a href="reproduction-and-transformation.html#summary-of-the-model-9"><i class="fa fa-check"></i><b>10.5</b> Summary of the model</a></li>
<li class="chapter" data-level="10.6" data-path="reproduction-and-transformation.html"><a href="reproduction-and-transformation.html#further-readings-3"><i class="fa fa-check"></i><b>10.6</b> Further readings</a></li>
</ul></li>
<li class="chapter" data-level="11" data-path="social-learning-of-social-learning-rules.html"><a href="social-learning-of-social-learning-rules.html"><i class="fa fa-check"></i><b>11</b> Social learning of social learning rules</a><ul>
<li class="chapter" data-level="11.1" data-path="social-learning-of-social-learning-rules.html"><a href="social-learning-of-social-learning-rules.html#openness-and-conservatism"><i class="fa fa-check"></i><b>11.1</b> Openness and conservatism</a></li>
<li class="chapter" data-level="11.2" data-path="social-learning-of-social-learning-rules.html"><a href="social-learning-of-social-learning-rules.html#maintaining-open-populations"><i class="fa fa-check"></i><b>11.2</b> Maintaining open populations</a></li>
<li class="chapter" data-level="11.3" data-path="social-learning-of-social-learning-rules.html"><a href="social-learning-of-social-learning-rules.html#summary-of-the-model-10"><i class="fa fa-check"></i><b>11.3</b> Summary of the model</a></li>
<li class="chapter" data-level="11.4" data-path="social-learning-of-social-learning-rules.html"><a href="social-learning-of-social-learning-rules.html#further-readings-4"><i class="fa fa-check"></i><b>11.4</b> Further readings</a></li>
</ul></li>
<li class="chapter" data-level="12" data-path="traits-inter-dependence.html"><a href="traits-inter-dependence.html"><i class="fa fa-check"></i><b>12</b> Traits inter-dependence</a><ul>
<li class="chapter" data-level="12.1" data-path="traits-inter-dependence.html"><a href="traits-inter-dependence.html#compatible-and-incompatible-traits"><i class="fa fa-check"></i><b>12.1</b> Compatible and incompatible traits</a></li>
<li class="chapter" data-level="12.2" data-path="traits-inter-dependence.html"><a href="traits-inter-dependence.html#many-traits-model"><i class="fa fa-check"></i><b>12.2</b> Many-traits model</a></li>
<li class="chapter" data-level="12.3" data-path="traits-inter-dependence.html"><a href="traits-inter-dependence.html#summary-of-the-model-11"><i class="fa fa-check"></i><b>12.3</b> Summary of the model</a></li>
<li class="chapter" data-level="12.4" data-path="traits-inter-dependence.html"><a href="traits-inter-dependence.html#further-readings-5"><i class="fa fa-check"></i><b>12.4</b> Further readings</a></li>
</ul></li>
<li class="part"><span><b>Advanced topics - Culture and populations</b></span></li>
<li class="chapter" data-level="13" data-path="demography.html"><a href="demography.html"><i class="fa fa-check"></i><b>13</b> Demography</a><ul>
<li class="chapter" data-level="13.1" data-path="demography.html"><a href="demography.html#the-tasmania-case"><i class="fa fa-check"></i><b>13.1</b> The Tasmania Case</a></li>
<li class="chapter" data-level="13.2" data-path="demography.html"><a href="demography.html#modelling-the-tasmania-case"><i class="fa fa-check"></i><b>13.2</b> Modelling the Tasmania Case</a></li>
<li class="chapter" data-level="13.3" data-path="demography.html"><a href="demography.html#calculating-critical-population-sizes-based-on-skill-complexity"><i class="fa fa-check"></i><b>13.3</b> Calculating critical population sizes based on skill complexity</a></li>
<li class="chapter" data-level="13.4" data-path="demography.html"><a href="demography.html#summary-of-the-model-12"><i class="fa fa-check"></i><b>13.4</b> Summary of the model</a></li>
<li class="chapter" data-level="13.5" data-path="demography.html"><a href="demography.html#further-readings-6"><i class="fa fa-check"></i><b>13.5</b> Further readings</a></li>
</ul></li>
<li class="chapter" data-level="14" data-path="social-network-structure.html"><a href="social-network-structure.html"><i class="fa fa-check"></i><b>14</b> Social network structure</a><ul>
<li class="chapter" data-level="14.1" data-path="social-network-structure.html"><a href="social-network-structure.html#network-basics"><i class="fa fa-check"></i><b>14.1</b> Network basics</a></li>
<li class="chapter" data-level="14.2" data-path="social-network-structure.html"><a href="social-network-structure.html#generating-networks"><i class="fa fa-check"></i><b>14.2</b> Generating networks</a></li>
<li class="chapter" data-level="14.3" data-path="social-network-structure.html"><a href="social-network-structure.html#plotting-networks"><i class="fa fa-check"></i><b>14.3</b> Plotting networks</a><ul>
<li class="chapter" data-level="14.3.1" data-path="social-network-structure.html"><a href="social-network-structure.html#network-layout"><i class="fa fa-check"></i><b>14.3.1</b> Network layout</a></li>
<li class="chapter" data-level="14.3.2" data-path="social-network-structure.html"><a href="social-network-structure.html#network-styling"><i class="fa fa-check"></i><b>14.3.2</b> Network styling</a></li>
</ul></li>
<li class="chapter" data-level="14.4" data-path="social-network-structure.html"><a href="social-network-structure.html#analyse-social-networks"><i class="fa fa-check"></i><b>14.4</b> Analyse social networks</a><ul>
<li class="chapter" data-level="14.4.1" data-path="social-network-structure.html"><a href="social-network-structure.html#network-properties-and-characteristics"><i class="fa fa-check"></i><b>14.4.1</b> Network properties and characteristics</a></li>
<li class="chapter" data-level="14.4.2" data-path="social-network-structure.html"><a href="social-network-structure.html#vertex-properties"><i class="fa fa-check"></i><b>14.4.2</b> Vertex properties</a></li>
</ul></li>
<li class="chapter" data-level="14.5" data-path="social-network-structure.html"><a href="social-network-structure.html#modelling-information-transmission-in-social-networks"><i class="fa fa-check"></i><b>14.5</b> Modelling information transmission in social networks</a><ul>
<li class="chapter" data-level="14.5.1" data-path="social-network-structure.html"><a href="social-network-structure.html#gossip-diffusion-in-networked-populations"><i class="fa fa-check"></i><b>14.5.1</b> Gossip diffusion in networked populations</a></li>
<li class="chapter" data-level="14.5.2" data-path="social-network-structure.html"><a href="social-network-structure.html#complex-versus-simple-contagion-information-transmission"><i class="fa fa-check"></i><b>14.5.2</b> Complex versus simple contagion information transmission</a></li>
</ul></li>
<li class="chapter" data-level="14.6" data-path="social-network-structure.html"><a href="social-network-structure.html#summary-of-the-model-13"><i class="fa fa-check"></i><b>14.6</b> Summary of the model</a></li>
<li class="chapter" data-level="14.7" data-path="social-network-structure.html"><a href="social-network-structure.html#further-reading-7"><i class="fa fa-check"></i><b>14.7</b> Further Reading</a></li>
</ul></li>
<li class="chapter" data-level="15" data-path="group-structured-populations-and-migration.html"><a href="group-structured-populations-and-migration.html"><i class="fa fa-check"></i><b>15</b> Group structured populations and migration</a><ul>
<li class="chapter" data-level="15.1" data-path="group-structured-populations-and-migration.html"><a href="group-structured-populations-and-migration.html#modelling-migration-and-contact-between-population-subsets"><i class="fa fa-check"></i><b>15.1</b> Modelling migration and contact between population subsets</a></li>
<li class="chapter" data-level="15.2" data-path="group-structured-populations-and-migration.html"><a href="group-structured-populations-and-migration.html#subdivided-population-with-limited-contact"><i class="fa fa-check"></i><b>15.2</b> Subdivided population with limited contact</a></li>
<li class="chapter" data-level="15.3" data-path="group-structured-populations-and-migration.html"><a href="group-structured-populations-and-migration.html#subdivided-populations-with-migration"><i class="fa fa-check"></i><b>15.3</b> Subdivided populations with migration</a></li>
<li class="chapter" data-level="15.4" data-path="group-structured-populations-and-migration.html"><a href="group-structured-populations-and-migration.html#varying-contact-and-migration-probability-for-repeated-simulation-runs"><i class="fa fa-check"></i><b>15.4</b> Varying contact and migration probability for repeated simulation runs</a></li>
<li class="chapter" data-level="15.5" data-path="group-structured-populations-and-migration.html"><a href="group-structured-populations-and-migration.html#model-extensions"><i class="fa fa-check"></i><b>15.5</b> Model extensions</a><ul>
<li class="chapter" data-level="" data-path="group-structured-populations-and-migration.html"><a href="group-structured-populations-and-migration.html#innovation-or-mutation"><i class="fa fa-check"></i>Innovation or mutation</a></li>
<li><a href="group-structured-populations-and-migration.html#copy-m-models">Copy <span class="math inline">\(m\)</span> models</a></li>
<li class="chapter" data-level="" data-path="group-structured-populations-and-migration.html"><a href="group-structured-populations-and-migration.html#variable-migration-probability-among-subsets"><i class="fa fa-check"></i>Variable migration probability among subsets</a></li>
</ul></li>
<li class="chapter" data-level="15.6" data-path="group-structured-populations-and-migration.html"><a href="group-structured-populations-and-migration.html#summary-of-the-model-14"><i class="fa fa-check"></i><b>15.6</b> Summary of the model</a></li>
<li class="chapter" data-level="15.7" data-path="group-structured-populations-and-migration.html"><a href="group-structured-populations-and-migration.html#further-reading-8"><i class="fa fa-check"></i><b>15.7</b> Further reading</a></li>
</ul></li>
<li class="chapter" data-level="" data-path="references.html"><a href="references.html"><i class="fa fa-check"></i>References</a></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Individual-based models of cultural evolution</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="social-network-structure" class="section level1">
<h1><span class="header-section-number">Chapter 14</span> Social network structure</h1>
<p>For mathematical tractability models often assume well-mixed populations, where any individual is equally likely to interact with any other individual. These models can provide good approximations of the real-world. Henrich’s model from the <a href="demography.html#demography">previous chapter</a>, for example, has shown that a population’s ability to maintain and accumulate cultural traits depends on its size, whereby larger populations are more likely to retain and improve more complex cultural traits than smaller ones. This model provides useful insights into the role of population-level characteristics (here, demography) on cultural dynamics. However, cultural transmission is a social process that happens at the individual level, and for some questions, it is important to take an individual-level perspective. There is a growing number of studies showing that the structure of interactions (commonly represented as social networks) with other individuals can affect the population-wide transmission of behaviours or information. For example, a study on the spread of health behaviour has shown that information spreads faster and further in networks that are more clustered than in less clustered networks (<span class="citation">Centola (<a href="references.html#ref-centola_spread_2010" role="doc-biblioref">2010</a>)</span>). To study the role of network characteristics (size, density, clustering, etc.) we need to be able to implement, modify, visualise, and analyse networks. We will cover all of these points in the first half of this chapter. In the second half, we will use these skills to study how social network structure affects cultural dynamics.</p>
<div id="network-basics" class="section level2">
<h2><span class="header-section-number">14.1</span> Network basics</h2>
<p>Networks are a popular tool to visualise relationships between different actors. For example, co-authorship networks typically visualise which authors frequently publish articles together, ecological networks demonstrate trophic interactions between different species, and kinship networks show how individuals are related to each other. All networks are comprised of at least two components: ‘nodes’ (also referred to as vertex, <em>pl.</em> vertices), which represent actors, and ‘ties’ (also referred to as edges) between any two nodes, which represent the existence of a relationship (e.g. co-authorship, kinship, cooperation, etc.).</p>
<div class="figure"><span id="fig:14-1"></span>
<img src="IBM-cultevo_files/figure-html/14-1-1.png" alt="An example network." width="672" />
<p class="caption">
Figure 14.1: An example network.
</p>
</div>
<p>The above figure shows a simple graph with four nodes (A-D), and their relationship edges (arrows). Note that some nodes have an incoming and an outgoing edge to another node (e.g. B and D) but some nodes have more incoming than outgoing edges (here C). This means that the relationship is not mutual, or reciprocal, like in the case of friendship or donations. In other cases, e.g. kinship ties, edges are always reciprocal. In this case, arrowheads are often omitted and a straight line is drawn between the nodes.</p>
<p>To work with networks in R, we need to find a way to represent nodes and edges. One option is to use an adjacency matrix (the other is an edge list, which we will not discuss here). An adjacency matrix is a square matrix where every possible relationship between any two actors (also called a dyad), is represented as a value (typically a <span class="math inline">\(0\)</span> if there is no relationship, or a <span class="math inline">\(1\)</span> if there is one). Generally, rows and columns represent the ‘from’ and ‘to’ nodes. As an example, assume we have <span class="math inline">\(N\)</span> actors, then our adjacency matrix <span class="math inline">\(A\)</span> will be of the size <span class="math inline">\(N \times N\)</span>. If individual <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> have a reciprocal relationship, then <span class="math inline">\(A_{i,j}=A_{ji}=1\)</span>. However, if, say, <span class="math inline">\(i\)</span> has donated to <span class="math inline">\(j\)</span> at some point but <span class="math inline">\(j\)</span> not to <span class="math inline">\(i\)</span>, then we would write <span class="math inline">\(A_{ij}=1\)</span> and <span class="math inline">\(A_{ji}=0\)</span>. Consequentially, if there is no relationship between the two then <span class="math inline">\(A_{i,j}=A_{ji}=0\)</span>. Let us translate this into R code.</p>
<p>We start by setting up a simple square matrix with a few zeros and ones. Let us also name the rows and columns with capital letters, using the <code>LETTERS</code> constant, built into R. These will be the names of the nodes.</p>
<div class="sourceCode" id="cb178"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb178-1"><a href="social-network-structure.html#cb178-1"></a>m &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>, <span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>, <span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>, <span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>), <span class="dt">nrow =</span> <span class="dv">4</span>, <span class="dt">byrow =</span> <span class="ot">TRUE</span>)</span>
<span id="cb178-2"><a href="social-network-structure.html#cb178-2"></a><span class="kw">row.names</span>(m) &lt;-<span class="st"> </span>LETTERS[<span class="dv">1</span><span class="op">:</span><span class="dv">4</span>]</span>
<span id="cb178-3"><a href="social-network-structure.html#cb178-3"></a><span class="kw">colnames</span>(m) &lt;-<span class="st"> </span>LETTERS[<span class="dv">1</span><span class="op">:</span><span class="dv">4</span>]</span>
<span id="cb178-4"><a href="social-network-structure.html#cb178-4"></a>m</span></code></pre></div>
<pre><code>##   A B C D
## A 0 1 1 0
## B 0 0 1 0
## C 1 0 0 1
## D 0 0 1 0</code></pre>
<p>Let’s have a look at the resulting matrix <code>m</code>. It describes the relationships between four individuals: A, B, C, and D. When we look at the first row, we see that A has no interaction with itself (indicated by the zero), but interacts both with B and C (indicated by the ones). From the next row, we see that B is only interacting with C, and so forth. You might notice that this is the adjacency matrix that we used for the network graph above. This adjacency matrix is also called an asymmetric adjacency matrix because not all interactions are reciprocal. We can see this when we plot the network but we can also test using a bit of code.</p>
<p>Let’s think, under which condition are all interactions reciprocal? The answer is when for all <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> it is true that <span class="math inline">\(A_{ij}=A_{ji}\)</span>. In other words, if the entries of <span class="math inline">\(A\)</span>’s upper triangle are identical to the entries of its lower triangle. To return only the values of the upper triangle of our matrix, we can use the <code>upper.tri()</code> function. It uses the matrix itself as an argument to return a matrix of the same size with <code>TRUE</code> for entries that are part of the upper triangle, and <code>FALSE</code> for all other entries. We use this to select the correct values from our matrix. We can then compare these values with the upper triangle of the transposed version of the matrix (we transpose using the <code>t()</code> function). If <code>all()</code> entries are identical, we know that we have a symmetric matrix.</p>
<div class="sourceCode" id="cb180"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb180-1"><a href="social-network-structure.html#cb180-1"></a><span class="kw">all</span>(m[<span class="kw">upper.tri</span>(m)] <span class="op">==</span><span class="st"> </span><span class="kw">t</span>(m)[<span class="kw">upper.tri</span>(m)])</span></code></pre></div>
<pre><code>## [1] FALSE</code></pre>
<p>As we have already determined, <span class="math inline">\(A\)</span> is asymmetric. If you want a short cut to test whether a matrix is symmetric, you can also use the generic function <code>isSymmetric()</code>.</p>
<div class="sourceCode" id="cb182"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb182-1"><a href="social-network-structure.html#cb182-1"></a><span class="kw">isSymmetric</span>(m)</span></code></pre></div>
<pre><code>## [1] FALSE</code></pre>
<p>Sometimes, you might want to create a random network using a symmetric adjacency matrix. A simple way to create a symmetric adjacency matrix is the following: create a random square matrix and then copy the entries from the transposed upper triangle into the entries of the lower triangle. This ensures that <span class="math inline">\(A_{ij}=A_{ji}\)</span>.</p>
<div class="sourceCode" id="cb184"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb184-1"><a href="social-network-structure.html#cb184-1"></a><span class="co"># Creating a random matrix</span></span>
<span id="cb184-2"><a href="social-network-structure.html#cb184-2"></a>random_matrix &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">sample</span>(<span class="dt">x =</span> <span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>), <span class="dt">size =</span> <span class="dv">100</span>, <span class="dt">replace =</span> T), <span class="dt">ncol =</span> <span class="dv">10</span>)</span>
<span id="cb184-3"><a href="social-network-structure.html#cb184-3"></a>random_matrix</span></code></pre></div>
<pre><code>##       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
##  [1,]    1    0    1    1    0    0    1    0    0     1
##  [2,]    0    1    1    0    0    0    1    1    0     1
##  [3,]    1    1    0    0    0    0    1    0    0     1
##  [4,]    0    0    0    0    1    0    1    1    1     1
##  [5,]    1    0    0    1    0    0    1    0    1     0
##  [6,]    0    0    0    0    0    0    1    0    1     0
##  [7,]    0    0    0    1    0    1    0    0    0     0
##  [8,]    0    0    1    0    1    0    0    0    1     1
##  [9,]    1    0    1    0    0    1    1    1    1     0
## [10,]    1    1    1    0    1    0    0    1    1     0</code></pre>
<div class="sourceCode" id="cb186"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb186-1"><a href="social-network-structure.html#cb186-1"></a><span class="co"># It is not symmetric</span></span>
<span id="cb186-2"><a href="social-network-structure.html#cb186-2"></a><span class="kw">isSymmetric</span>(random_matrix)</span></code></pre></div>
<pre><code>## [1] FALSE</code></pre>
<div class="sourceCode" id="cb188"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb188-1"><a href="social-network-structure.html#cb188-1"></a><span class="co"># Replace the upper triangle with the transposed upper triangle</span></span>
<span id="cb188-2"><a href="social-network-structure.html#cb188-2"></a>random_matrix[<span class="kw">upper.tri</span>(random_matrix)] &lt;-<span class="st"> </span><span class="kw">t</span>(random_matrix)[<span class="kw">upper.tri</span>(random_matrix)]</span>
<span id="cb188-3"><a href="social-network-structure.html#cb188-3"></a>random_matrix</span></code></pre></div>
<pre><code>##       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
##  [1,]    1    0    1    0    1    0    0    0    1     1
##  [2,]    0    1    1    0    0    0    0    0    0     1
##  [3,]    1    1    0    0    0    0    0    1    1     1
##  [4,]    0    0    0    0    1    0    1    0    0     0
##  [5,]    1    0    0    1    0    0    0    1    0     1
##  [6,]    0    0    0    0    0    0    1    0    1     0
##  [7,]    0    0    0    1    0    1    0    0    1     0
##  [8,]    0    0    1    0    1    0    0    0    1     1
##  [9,]    1    0    1    0    0    1    1    1    1     1
## [10,]    1    1    1    0    1    0    0    1    1     0</code></pre>
<div class="sourceCode" id="cb190"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb190-1"><a href="social-network-structure.html#cb190-1"></a><span class="co"># Now it is symmetric</span></span>
<span id="cb190-2"><a href="social-network-structure.html#cb190-2"></a><span class="kw">isSymmetric</span>(random_matrix)</span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
</div>
<div id="generating-networks" class="section level2">
<h2><span class="header-section-number">14.2</span> Generating networks</h2>
<p>Networks can vary widely depending on what they represent, or what their purpose is if they are simulate from scratch. The figure below shows a few different types of networks that require different methods to create. A simple way to generate certain types of networks with, say, different number of nodes and edges, is to use one of the many functions provided by the <code>igraph</code> package. For example, the ring graph below can be generated with this simple command: <code>make_ring(n = 10)</code>.</p>
<!--@Alberto, the following code chunk will only display a figure, not the code.-->
<div class="figure"><span id="fig:14-6"></span>
<img src="IBM-cultevo_files/figure-html/14-6-1.png" alt="Different graph types (from left: circle, lattice, random, scale free, fully connected) vary in the density and distribution of edges between nodes." width="672" />
<p class="caption">
Figure 14.2: Different graph types (from left: circle, lattice, random, scale free, fully connected) vary in the density and distribution of edges between nodes.
</p>
</div>
<p>For certain projects, these standard networks might not be sufficient, for example, if you have a certain mechanism in mind. Let us write our own network generating function to suit our needs. As an example, let us write a function that creates a random network of <span class="math inline">\(N\)</span> individuals. Let’s assume that the edges we will add between nodes represent friendships, with a variable friendship proportion <span class="math inline">\(f\)</span> (for <span class="math inline">\(f=1\)</span> all individuals are friends, and for <span class="math inline">\(f=0\)</span>, sadly no one is friends with each other).</p>
<div class="sourceCode" id="cb192"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb192-1"><a href="social-network-structure.html#cb192-1"></a>create_network &lt;-<span class="st"> </span><span class="cf">function</span>(N, f){</span>
<span id="cb192-2"><a href="social-network-structure.html#cb192-2"></a>  <span class="co"># Set up an empty adjacency matrix of size NxN</span></span>
<span id="cb192-3"><a href="social-network-structure.html#cb192-3"></a>  A &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>, <span class="dt">ncol =</span> N, <span class="dt">nrow =</span> N)</span>
<span id="cb192-4"><a href="social-network-structure.html#cb192-4"></a>  <span class="co"># Set up a friendship counter</span></span>
<span id="cb192-5"><a href="social-network-structure.html#cb192-5"></a>  friends &lt;-<span class="st"> </span><span class="dv">0</span></span>
<span id="cb192-6"><a href="social-network-structure.html#cb192-6"></a>  </span>
<span id="cb192-7"><a href="social-network-structure.html#cb192-7"></a>  <span class="co"># We will add friendships until we reach the desired number</span></span>
<span id="cb192-8"><a href="social-network-structure.html#cb192-8"></a>  <span class="cf">while</span>(friends <span class="op">&lt;</span><span class="st"> </span><span class="kw">round</span>((((N<span class="op">^</span><span class="dv">2</span>) <span class="op">-</span><span class="st"> </span>N) <span class="op">/</span><span class="st"> </span><span class="dv">2</span>) <span class="op">*</span><span class="st"> </span>f)){</span>
<span id="cb192-9"><a href="social-network-structure.html#cb192-9"></a>    dyad &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dt">x =</span> N, <span class="dt">size =</span> <span class="dv">2</span>, <span class="dt">replace =</span> <span class="ot">FALSE</span>)</span>
<span id="cb192-10"><a href="social-network-structure.html#cb192-10"></a>    i &lt;-<span class="st"> </span>dyad[<span class="dv">1</span>]</span>
<span id="cb192-11"><a href="social-network-structure.html#cb192-11"></a>    j &lt;-<span class="st"> </span>dyad[<span class="dv">2</span>]</span>
<span id="cb192-12"><a href="social-network-structure.html#cb192-12"></a>    <span class="cf">if</span>(A[i, j] <span class="op">==</span><span class="st"> </span><span class="dv">0</span>){</span>
<span id="cb192-13"><a href="social-network-structure.html#cb192-13"></a>      A[i, j] &lt;-<span class="st"> </span>A[j, i] &lt;-<span class="st"> </span><span class="dv">1</span></span>
<span id="cb192-14"><a href="social-network-structure.html#cb192-14"></a>      friends &lt;-<span class="st"> </span>friends <span class="op">+</span><span class="st"> </span><span class="dv">1</span></span>
<span id="cb192-15"><a href="social-network-structure.html#cb192-15"></a>      }</span>
<span id="cb192-16"><a href="social-network-structure.html#cb192-16"></a>  }</span>
<span id="cb192-17"><a href="social-network-structure.html#cb192-17"></a>  <span class="kw">return</span>(A)</span>
<span id="cb192-18"><a href="social-network-structure.html#cb192-18"></a>}</span></code></pre></div>
<p>In our new function <code>create_network()</code> we first set up an empty adjacency matrix and a friendship counter. Then, we use a <code>while</code> loop to continuously select a random dyad in our group (i.e. individual <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span>), test whether they are already friends. If this is not the case, we set <span class="math inline">\(A_{ij}=A_{ji}=1\)</span> and increase the friendship counter. However, if they already are friends, we simply continue selecting another random dyad from our network. We stop when we reach <span class="math inline">\(f(N^2-N)/2\)</span> friendships (the total number of possible connections is <span class="math inline">\(N^2\)</span>, however, we assume that individuals cannot be friends with themselves and that friendships are reciprocal).</p>
<p>Our new function allows us to create a variety of different networks. One can generate, for example, a network with 10 individuals, that have 50% of probability of being friend of each other.</p>
<div class="sourceCode" id="cb193"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb193-1"><a href="social-network-structure.html#cb193-1"></a>adjm &lt;-<span class="st"> </span><span class="kw">create_network</span>(<span class="dt">N =</span> <span class="dv">10</span>, <span class="dt">f =</span> <span class="fl">.5</span>)</span>
<span id="cb193-2"><a href="social-network-structure.html#cb193-2"></a>adjm</span></code></pre></div>
<pre><code>##       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
##  [1,]    0    1    0    0    0    0    0    1    1     1
##  [2,]    1    0    1    0    0    0    1    0    1     0
##  [3,]    0    1    0    0    0    0    1    0    1     0
##  [4,]    0    0    0    0    1    1    0    0    1     0
##  [5,]    0    0    0    1    0    0    0    1    1     0
##  [6,]    0    0    0    1    0    0    1    1    1     1
##  [7,]    0    1    1    0    0    1    0    0    0     1
##  [8,]    1    0    0    0    1    1    0    0    1     1
##  [9,]    1    1    1    1    1    1    0    1    0     1
## [10,]    1    0    0    0    0    1    1    1    1     0</code></pre>
<p>Let us now use additional functions from the <code>igraph</code> package to turn our adjacency matrices in networks and then to visualise them. This will give us a better intuition of what our groups look like when we change the two parameters.</p>
</div>
<div id="plotting-networks" class="section level2">
<h2><span class="header-section-number">14.3</span> Plotting networks</h2>
<p>To visualise a network nodes and edges have to be placed in the correct relation to each other on an empty canvas. Because there is a lot of calculation going into this, we will use the plotting features that come with the <code>igraph</code> package. This package requires the network to be an <code>IGRAPH</code> object. So first, we will have to turn our adjacency matrix into a network. The function <code>graph_from_adjacency_matrix()</code> is going to do this for us:</p>
<div class="sourceCode" id="cb195"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb195-1"><a href="social-network-structure.html#cb195-1"></a><span class="kw">library</span>(igraph)</span>
<span id="cb195-2"><a href="social-network-structure.html#cb195-2"></a>net &lt;-<span class="st"> </span><span class="kw">graph_from_adjacency_matrix</span>(adjm)</span>
<span id="cb195-3"><a href="social-network-structure.html#cb195-3"></a>net</span></code></pre></div>
<pre><code>## IGRAPH ec7284e D--- 10 44 -- 
## + edges from ec7284e:
##  [1]  1-&gt; 2  1-&gt; 8  1-&gt; 9  1-&gt;10  2-&gt; 1  2-&gt; 3  2-&gt; 7  2-&gt; 9  3-&gt; 2  3-&gt; 7
## [11]  3-&gt; 9  4-&gt; 5  4-&gt; 6  4-&gt; 9  5-&gt; 4  5-&gt; 8  5-&gt; 9  6-&gt; 4  6-&gt; 7  6-&gt; 8
## [21]  6-&gt; 9  6-&gt;10  7-&gt; 2  7-&gt; 3  7-&gt; 6  7-&gt;10  8-&gt; 1  8-&gt; 5  8-&gt; 6  8-&gt; 9
## [31]  8-&gt;10  9-&gt; 1  9-&gt; 2  9-&gt; 3  9-&gt; 4  9-&gt; 5  9-&gt; 6  9-&gt; 8  9-&gt;10 10-&gt; 1
## [41] 10-&gt; 6 10-&gt; 7 10-&gt; 8 10-&gt; 9</code></pre>
<p>If we enter the name of the network <code>net</code> we are provided with a lot of information, for example, that <code>net</code> is an <code>IGRAPH</code> object and that there are 10 vertices and 44 edges (for more information on reading this output take a look at this short <a href="https://igraph.org/r/doc/aaa-igraph-package.html">igraph introduction</a>). In addition to general information about the network, we receive a series of ‘from to’ pairs, e.g. <code>1-&gt;3</code>, indicating the edges between the different nodes. This is essentially an edge list, an alternative to our adjacency matrix to describe relationships. Sometimes, it might be better to work with an edgelist, especially if there are many more nodes than edges. In this case, we would require a very large matrix that is mostly filled with zeros and only very few ones. You can use <code>get.edgelist(net)</code> to return the edgelist of your network.</p>
<p>Now that we have our network in the correct shape, we can use the plot function to visualise it:</p>
<div class="sourceCode" id="cb197"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb197-1"><a href="social-network-structure.html#cb197-1"></a><span class="kw">plot</span>(net)</span></code></pre></div>
<div class="figure"><span id="fig:14-10"></span>
<img src="IBM-cultevo_files/figure-html/14-10-1.png" alt="A simple network with 10 vertices, which are connected by edges (arrows)." width="672" />
<p class="caption">
Figure 14.3: A simple network with 10 vertices, which are connected by edges (arrows).
</p>
</div>
<p>This is the most basic network plot where each node (with the numbers 1 to 10) and their edges are plotted such that nodes that receive more connections are more central and those that receive less are more peripheral.</p>
<div id="network-layout" class="section level3">
<h3><span class="header-section-number">14.3.1</span> Network layout</h3>
<p>There are also ways to plot networks in entirely different layouts. In the following graph, for example, we put nodes in a ring layout or on a grid. We use the different <code>layout.x()</code> functions in <code>ìgraph</code> in combination with the <code>layout=</code> argument of the plotting function. Notice we are not using the usual <code>ggplot</code> function to plot, as we make use of the specific functionalities of <code>igraph</code>.</p>
<div class="sourceCode" id="cb198"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb198-1"><a href="social-network-structure.html#cb198-1"></a><span class="co"># Set the plotting environment to allow 2 plots next to each other</span></span>
<span id="cb198-2"><a href="social-network-structure.html#cb198-2"></a><span class="kw">par</span>(<span class="dt">mfrow =</span> <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>))</span>
<span id="cb198-3"><a href="social-network-structure.html#cb198-3"></a><span class="kw">plot</span>(net, <span class="dt">layout =</span> <span class="kw">layout.circle</span>(net), <span class="dt">main =</span> <span class="st">&quot;Ring layout&quot;</span>)</span>
<span id="cb198-4"><a href="social-network-structure.html#cb198-4"></a><span class="kw">plot</span>(net, <span class="dt">layout =</span> <span class="kw">layout.grid</span>(net), <span class="dt">main =</span> <span class="st">&quot;Grid layout&quot;</span>)</span></code></pre></div>
<div class="figure"><span id="fig:14-11"></span>
<img src="IBM-cultevo_files/figure-html/14-11-1.png" alt="Example for two different network layouts, the grid and the ring." width="672" />
<p class="caption">
Figure 14.4: Example for two different network layouts, the grid and the ring.
</p>
</div>
<div class="sourceCode" id="cb199"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb199-1"><a href="social-network-structure.html#cb199-1"></a><span class="co"># Reset the plotting environment to a single plot</span></span>
<span id="cb199-2"><a href="social-network-structure.html#cb199-2"></a><span class="kw">par</span>(<span class="dt">mfrow =</span> <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>))</span></code></pre></div>
<p>There are many more layout functions that will result in slightly different visualisations, based on how degree or centrality are weighted (bringing nodes closer together or keeping them further apart). All of these functions start with the term <code>layout</code>.</p>
<p>Another important use-case for using <code>layout_</code> functions is to retain the position of nodes when plotting the same network repeatedly. If we do not store the layout of a graph, the plotting command will generate slightly different network visualisations every time we run it. To preserve the node position we can return each vertices coordinate and then hand this over to the plotting function whenever we plot the same network:</p>
<div class="sourceCode" id="cb200"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb200-1"><a href="social-network-structure.html#cb200-1"></a><span class="kw">par</span>(<span class="dt">mfrow =</span> <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">3</span>))</span>
<span id="cb200-2"><a href="social-network-structure.html#cb200-2"></a>coords &lt;-<span class="st"> </span><span class="kw">layout.fruchterman.reingold</span>(net)</span>
<span id="cb200-3"><a href="social-network-structure.html#cb200-3"></a><span class="kw">plot</span>(net, <span class="dt">layout =</span> coords, <span class="dt">main =</span> <span class="st">&quot;Original&quot;</span>)</span>
<span id="cb200-4"><a href="social-network-structure.html#cb200-4"></a><span class="kw">plot</span>(net, <span class="dt">main =</span> <span class="st">&quot;Without layout&quot;</span>)</span>
<span id="cb200-5"><a href="social-network-structure.html#cb200-5"></a><span class="kw">plot</span>(net, <span class="dt">layout =</span> coords, <span class="dt">main =</span> <span class="st">&quot;With layout&quot;</span>)</span></code></pre></div>
<div class="figure"><span id="fig:14-12"></span>
<img src="IBM-cultevo_files/figure-html/14-12-1.png" alt="Using vertex coordinates preserves the exact layout of a network." width="672" />
<p class="caption">
Figure 14.5: Using vertex coordinates preserves the exact layout of a network.
</p>
</div>
<div class="sourceCode" id="cb201"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb201-1"><a href="social-network-structure.html#cb201-1"></a><span class="kw">par</span>(<span class="dt">mfrow =</span> <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>))</span></code></pre></div>
</div>
<div id="network-styling" class="section level3">
<h3><span class="header-section-number">14.3.2</span> Network styling</h3>
<p>In addition to the layout, which affects the placing of nodes, we can also change the actual appearance of nodes and edges, such as their size and width, colour, labelling, and more. While the igraph manual is a good reference to figure out all the possibilities, here is the general principle: any attribute we want to change needs either the <code>vertex.</code> or <code>edge.</code> prefix. For example, to change the colour of all vertices, we would use <code>vertex.color=</code>. Have a look at the following example for more ideas of what we can change:</p>
<div class="sourceCode" id="cb202"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb202-1"><a href="social-network-structure.html#cb202-1"></a><span class="kw">plot</span>(net, </span>
<span id="cb202-2"><a href="social-network-structure.html#cb202-2"></a>     <span class="dt">vertex.color =</span> <span class="st">&quot;dodgerblue&quot;</span>, </span>
<span id="cb202-3"><a href="social-network-structure.html#cb202-3"></a>     <span class="dt">vertex.label.color =</span> <span class="st">&quot;white&quot;</span>,</span>
<span id="cb202-4"><a href="social-network-structure.html#cb202-4"></a>     <span class="dt">vertex.size =</span> <span class="dv">20</span>,</span>
<span id="cb202-5"><a href="social-network-structure.html#cb202-5"></a>     <span class="dt">edge.color =</span> <span class="st">&quot;black&quot;</span>,</span>
<span id="cb202-6"><a href="social-network-structure.html#cb202-6"></a>     <span class="dt">edge.width =</span> <span class="dv">1</span>,</span>
<span id="cb202-7"><a href="social-network-structure.html#cb202-7"></a>     <span class="dt">edge.arrow.size =</span> <span class="fl">0.5</span>,</span>
<span id="cb202-8"><a href="social-network-structure.html#cb202-8"></a>     <span class="dt">layout =</span> coords,</span>
<span id="cb202-9"><a href="social-network-structure.html#cb202-9"></a>     <span class="dt">main =</span> <span class="st">&quot;Default layout with styling&quot;</span>)</span></code></pre></div>
<div class="figure"><span id="fig:14-13"></span>
<img src="IBM-cultevo_files/figure-html/14-13-1.png" alt="Using syling arguments with the `plot()` function allows to manipulate the appearence of vertices, edges, and labels." width="672" />
<p class="caption">
Figure 14.6: Using syling arguments with the <code>plot()</code> function allows to manipulate the appearence of vertices, edges, and labels.
</p>
</div>
<p>As you can see in the graph above, we have changed the colour of the nodes and text, and their overall size (attributes starting with <code>vertex.</code>). We have also changed the colour of the edges, their width, and the size of the arrow tips (attributes starting with <code>edge.</code>).</p>
<p>Additional to colour our network, we can also use colour to indicate additional information. Say, we know the age of each individual that is represented by a node in out network. How can we instruct <code>plot()</code> to use a different colour for each node depending on its age? To do this, we need to first select colours to represent different ages. Then, we can hand this over to the <code>vertex.color</code> argument. Below, we use a function called <code>heat.colors()</code>. It creates a vector of <span class="math inline">\(n\)</span> contiguous colours that span the ‘heat’ colour space (from white over yellow to red). We generate 80 different shades and then select 10 colours (we use the <code>vcount()</code> function to count the number of vertices in our network) according to the <code>age</code> vector:</p>
<div class="sourceCode" id="cb203"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb203-1"><a href="social-network-structure.html#cb203-1"></a><span class="co"># Generate random ages</span></span>
<span id="cb203-2"><a href="social-network-structure.html#cb203-2"></a>age &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dt">x =</span> <span class="dv">18</span><span class="op">:</span><span class="dv">80</span>, <span class="dt">size =</span> <span class="kw">vcount</span>(net), <span class="dt">replace =</span> <span class="ot">TRUE</span>)</span>
<span id="cb203-3"><a href="social-network-structure.html#cb203-3"></a><span class="co"># Select colours</span></span>
<span id="cb203-4"><a href="social-network-structure.html#cb203-4"></a>col &lt;-<span class="st"> </span><span class="kw">heat.colors</span>(<span class="dt">n =</span> <span class="dv">80</span>, <span class="dt">rev =</span> <span class="ot">TRUE</span>)[age]</span>
<span id="cb203-5"><a href="social-network-structure.html#cb203-5"></a><span class="co"># Plot network with col</span></span>
<span id="cb203-6"><a href="social-network-structure.html#cb203-6"></a><span class="kw">plot</span>(net, </span>
<span id="cb203-7"><a href="social-network-structure.html#cb203-7"></a>     <span class="dt">vertex.color =</span> col, </span>
<span id="cb203-8"><a href="social-network-structure.html#cb203-8"></a>     <span class="dt">vertex.label =</span> age,</span>
<span id="cb203-9"><a href="social-network-structure.html#cb203-9"></a>     <span class="dt">vertex.label.color =</span> <span class="st">&quot;black&quot;</span>,</span>
<span id="cb203-10"><a href="social-network-structure.html#cb203-10"></a>     <span class="dt">vertex.size =</span> <span class="dv">20</span>,</span>
<span id="cb203-11"><a href="social-network-structure.html#cb203-11"></a>     <span class="dt">edge.color =</span> <span class="st">&quot;black&quot;</span>,</span>
<span id="cb203-12"><a href="social-network-structure.html#cb203-12"></a>     <span class="dt">edge.width =</span> <span class="dv">1</span>,</span>
<span id="cb203-13"><a href="social-network-structure.html#cb203-13"></a>     <span class="dt">edge.arrow.size =</span> <span class="fl">0.5</span>,</span>
<span id="cb203-14"><a href="social-network-structure.html#cb203-14"></a>     <span class="dt">layout =</span> coords,</span>
<span id="cb203-15"><a href="social-network-structure.html#cb203-15"></a>     <span class="dt">main =</span> <span class="st">&quot;Default layout with styling&quot;</span>)</span></code></pre></div>
<div class="figure"><span id="fig:14-14"></span>
<img src="IBM-cultevo_files/figure-html/14-14-1.png" alt="In this plot we indicate a node's age by colouring the node with a different colour (pale yellow: younger, red: older)" width="672" />
<p class="caption">
Figure 14.7: In this plot we indicate a node’s age by colouring the node with a different colour (pale yellow: younger, red: older)
</p>
</div>
<p>Compared to the previous plot, three things have changed: (1) the colour of the nodes, (2) the labels of the nodes (now indicating the correct age), and (3) the colour of the vertex text (black is easier to read on these colours).</p>
<p>It might be a good idea to keep both the <code>age</code> and the <code>col</code> vector attached to the vertices of our network. We can add them as attributes to the vertices of our network. Using the <code>get.vertex.attribute()</code> function we can see that currently there are no attributes stored at all:</p>
<div class="sourceCode" id="cb204"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb204-1"><a href="social-network-structure.html#cb204-1"></a><span class="kw">get.vertex.attribute</span>(net)</span></code></pre></div>
<pre><code>## list()</code></pre>
<p>Let us add the two attributes to the vertices using the <code>V()</code> function:</p>
<div class="sourceCode" id="cb206"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb206-1"><a href="social-network-structure.html#cb206-1"></a><span class="co"># Add an attribute called &#39;age&#39; and assign the values of the age vector</span></span>
<span id="cb206-2"><a href="social-network-structure.html#cb206-2"></a><span class="kw">V</span>(net)<span class="op">$</span>age &lt;-<span class="st"> </span>age</span>
<span id="cb206-3"><a href="social-network-structure.html#cb206-3"></a><span class="co"># The same for the &#39;col&#39; vector</span></span>
<span id="cb206-4"><a href="social-network-structure.html#cb206-4"></a><span class="kw">V</span>(net)<span class="op">$</span>col &lt;-<span class="st"> </span>col</span>
<span id="cb206-5"><a href="social-network-structure.html#cb206-5"></a><span class="co"># Return attributes</span></span>
<span id="cb206-6"><a href="social-network-structure.html#cb206-6"></a><span class="kw">get.vertex.attribute</span>(net)</span></code></pre></div>
<pre><code>## $age
##  [1] 37 43 79 42 48 32 43 46 41 64
## 
## $col
##  [1] &quot;#FFBA00&quot; &quot;#FFA000&quot; &quot;#FF0400&quot; &quot;#FFA400&quot; &quot;#FF8A00&quot; &quot;#FFCF00&quot; &quot;#FFA000&quot;
##  [8] &quot;#FF9300&quot; &quot;#FFA900&quot; &quot;#FF4500&quot;</code></pre>
<div class="sourceCode" id="cb208"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb208-1"><a href="social-network-structure.html#cb208-1"></a><span class="co"># Return the network object</span></span>
<span id="cb208-2"><a href="social-network-structure.html#cb208-2"></a>net</span></code></pre></div>
<pre><code>## IGRAPH ec7284e D--- 10 44 -- 
## + attr: age (v/n), col (v/c)
## + edges from ec7284e:
##  [1]  1-&gt; 2  1-&gt; 8  1-&gt; 9  1-&gt;10  2-&gt; 1  2-&gt; 3  2-&gt; 7  2-&gt; 9  3-&gt; 2  3-&gt; 7
## [11]  3-&gt; 9  4-&gt; 5  4-&gt; 6  4-&gt; 9  5-&gt; 4  5-&gt; 8  5-&gt; 9  6-&gt; 4  6-&gt; 7  6-&gt; 8
## [21]  6-&gt; 9  6-&gt;10  7-&gt; 2  7-&gt; 3  7-&gt; 6  7-&gt;10  8-&gt; 1  8-&gt; 5  8-&gt; 6  8-&gt; 9
## [31]  8-&gt;10  9-&gt; 1  9-&gt; 2  9-&gt; 3  9-&gt; 4  9-&gt; 5  9-&gt; 6  9-&gt; 8  9-&gt;10 10-&gt; 1
## [41] 10-&gt; 6 10-&gt; 7 10-&gt; 8 10-&gt; 9</code></pre>
<p>We now have two attributes that are associated with our network. To use them in plotting you can simply replace <code>age</code> in the previous plot with <code>V(net)$age</code> and <code>col</code> with <code>V(net)$col</code>. Also, have a look at the <code>net</code> object. It now also tells us that there are two attributes (one is called age, with numeric values, and one is called col, with character values).</p>
<p>Because we have colours representing the age, we may want to remove the labels in each node and make the nodes smaller. This becomes even more important when networks become large. For this, we can simply set <code>vertex.label</code> to <code>NULL</code>. Also, given that we have a symmetric network (all relationships are reciprocal), we can get rid of the arrow tips. We can do this by turning our network into an ‘undirected’ network, using the <code>as.undirected()</code> function:</p>
<div class="sourceCode" id="cb210"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb210-1"><a href="social-network-structure.html#cb210-1"></a>net &lt;-<span class="st"> </span><span class="kw">as.undirected</span>(net)</span>
<span id="cb210-2"><a href="social-network-structure.html#cb210-2"></a><span class="kw">plot</span>(net, </span>
<span id="cb210-3"><a href="social-network-structure.html#cb210-3"></a>     <span class="dt">vertex.color =</span> <span class="kw">V</span>(net)<span class="op">$</span>col, </span>
<span id="cb210-4"><a href="social-network-structure.html#cb210-4"></a>     <span class="dt">vertex.label =</span> <span class="ot">NA</span>,</span>
<span id="cb210-5"><a href="social-network-structure.html#cb210-5"></a>     <span class="dt">vertex.size =</span> <span class="dv">9</span>,</span>
<span id="cb210-6"><a href="social-network-structure.html#cb210-6"></a>     <span class="dt">edge.width =</span> <span class="dv">1</span>,</span>
<span id="cb210-7"><a href="social-network-structure.html#cb210-7"></a>     <span class="dt">layout =</span> coords,</span>
<span id="cb210-8"><a href="social-network-structure.html#cb210-8"></a>     <span class="dt">edge.arrow.size =</span> <span class="fl">0.5</span>)</span></code></pre></div>
<div class="figure"><span id="fig:14-17"></span>
<img src="IBM-cultevo_files/figure-html/14-17-1.png" alt="A cleaner version of the same network." width="672" />
<p class="caption">
Figure 14.8: A cleaner version of the same network.
</p>
</div>
<p>Similar to what we did with the nodes (using colour to represent additional information), we can also let edges represent additional information, for example, the width of the stroke can represent the strength of a relationship. Fatter lines could represent stronger friendships. In real life, you will probably have actual values (from experiments or simulations) that you want to use for each edge. Here, we draw 22 random values (using the <code>ecount()</code> function to count the number of edges) from a Uniform Distribution using the <code>runif()</code> function:</p>
<div class="sourceCode" id="cb211"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb211-1"><a href="social-network-structure.html#cb211-1"></a><span class="co"># Create random strength values</span></span>
<span id="cb211-2"><a href="social-network-structure.html#cb211-2"></a>strength &lt;-<span class="st"> </span><span class="kw">runif</span>(<span class="dt">n =</span> <span class="kw">ecount</span>(net), <span class="dt">min =</span> <span class="dv">0</span>, <span class="dt">max =</span> <span class="dv">1</span>)</span>
<span id="cb211-3"><a href="social-network-structure.html#cb211-3"></a><span class="co"># Assign values to edges</span></span>
<span id="cb211-4"><a href="social-network-structure.html#cb211-4"></a><span class="kw">E</span>(net)<span class="op">$</span>weight &lt;-<span class="st"> </span>strength</span>
<span id="cb211-5"><a href="social-network-structure.html#cb211-5"></a>net</span></code></pre></div>
<pre><code>## IGRAPH d846489 U-W- 10 22 -- 
## + attr: age (v/n), col (v/c), weight (e/n)
## + edges from d846489:
##  [1] 1-- 2 2-- 3 4-- 5 4-- 6 2-- 7 3-- 7 6-- 7 1-- 8 5-- 8 6-- 8 1-- 9 2-- 9
## [13] 3-- 9 4-- 9 5-- 9 6-- 9 8-- 9 1--10 6--10 7--10 8--10 9--10</code></pre>
<p>We assigned the friendship strength values to an attribute called <code>weight</code>. Take a look at the <code>net</code> object. It now says <code>U-W-</code>, indicating that it is both an <strong>u</strong>ndirected as well as a <strong>w</strong>eighted network. To plot the edge weights, we instruct the plotting function to use the <code>E(net)$weight</code> values for the <code>edge.width</code> parameter (note that we multiply the values by some value to make the strokes bigger in the final plot):</p>
<div class="sourceCode" id="cb213"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb213-1"><a href="social-network-structure.html#cb213-1"></a><span class="kw">plot</span>(net, </span>
<span id="cb213-2"><a href="social-network-structure.html#cb213-2"></a>     <span class="dt">vertex.color =</span> <span class="kw">V</span>(net)<span class="op">$</span>col, </span>
<span id="cb213-3"><a href="social-network-structure.html#cb213-3"></a>     <span class="dt">vertex.label =</span> <span class="ot">NA</span>,</span>
<span id="cb213-4"><a href="social-network-structure.html#cb213-4"></a>     <span class="dt">vertex.size =</span> <span class="dv">9</span>,</span>
<span id="cb213-5"><a href="social-network-structure.html#cb213-5"></a>     <span class="dt">edge.width =</span> <span class="kw">E</span>(net)<span class="op">$</span>weight<span class="op">*</span><span class="dv">5</span>,</span>
<span id="cb213-6"><a href="social-network-structure.html#cb213-6"></a>     <span class="dt">edge.arrow.size =</span> <span class="fl">0.5</span>, </span>
<span id="cb213-7"><a href="social-network-structure.html#cb213-7"></a>     <span class="dt">layout =</span> coords)</span></code></pre></div>
<div class="figure"><span id="fig:14-19"></span>
<img src="IBM-cultevo_files/figure-html/14-19-1.png" alt="To indicate different strength in the relationship of two nodes, we can vary the width of edge between them." width="672" />
<p class="caption">
Figure 14.9: To indicate different strength in the relationship of two nodes, we can vary the width of edge between them.
</p>
</div>
<p>You can now observe strong and weak relationships between individuals, their location relative to each other, and how they cluster. Let us now look at how to quantify the observed network characteristics.</p>
</div>
</div>
<div id="analyse-social-networks" class="section level2">
<h2><span class="header-section-number">14.4</span> Analyse social networks</h2>
<p>To describe networks, a set of specific terms and measures are used. Let us take a look at the most common measures. In principle, we distinguish between two different levels to describe properties that are associated with networks:</p>
<ul>
<li><p>Population-level network properties</p></li>
<li><p>Individual-level vertex properties</p></li>
</ul>
<div id="network-properties-and-characteristics" class="section level3">
<h3><span class="header-section-number">14.4.1</span> Network properties and characteristics</h3>
<p>To retrieve the most basic information about our network we can use the <code>V()</code> and <code>E()</code> function for vertices and edges of a given network.</p>
<div class="sourceCode" id="cb214"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb214-1"><a href="social-network-structure.html#cb214-1"></a><span class="kw">V</span>(net)</span></code></pre></div>
<pre><code>## + 10/10 vertices, from d846489:
##  [1]  1  2  3  4  5  6  7  8  9 10</code></pre>
<div class="sourceCode" id="cb216"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb216-1"><a href="social-network-structure.html#cb216-1"></a><span class="kw">E</span>(net)</span></code></pre></div>
<pre><code>## + 22/22 edges from d846489:
##  [1] 1-- 2 2-- 3 4-- 5 4-- 6 2-- 7 3-- 7 6-- 7 1-- 8 5-- 8 6-- 8 1-- 9 2-- 9
## [13] 3-- 9 4-- 9 5-- 9 6-- 9 8-- 9 1--10 6--10 7--10 8--10 9--10</code></pre>
<p>If our network has attributes associates for its vertices or edges, we can retrieve them with the following two functions:</p>
<div class="sourceCode" id="cb218"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb218-1"><a href="social-network-structure.html#cb218-1"></a><span class="kw">get.vertex.attribute</span>(<span class="dt">graph =</span> net)</span></code></pre></div>
<pre><code>## $age
##  [1] 37 43 79 42 48 32 43 46 41 64
## 
## $col
##  [1] &quot;#FFBA00&quot; &quot;#FFA000&quot; &quot;#FF0400&quot; &quot;#FFA400&quot; &quot;#FF8A00&quot; &quot;#FFCF00&quot; &quot;#FFA000&quot;
##  [8] &quot;#FF9300&quot; &quot;#FFA900&quot; &quot;#FF4500&quot;</code></pre>
<div class="sourceCode" id="cb220"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb220-1"><a href="social-network-structure.html#cb220-1"></a><span class="kw">get.edge.attribute</span>(net)</span></code></pre></div>
<pre><code>## $weight
##  [1] 0.818258529 0.920366649 0.231527153 0.693315767 0.008154522 0.805871333
##  [7] 0.435842459 0.883289981 0.393722419 0.740727710 0.220209768 0.390699380
## [13] 0.637780410 0.050760790 0.204548642 0.065545603 0.098845316 0.195471014
## [19] 0.328379263 0.028346302 0.158203278 0.348797554</code></pre>
<p>As you can see, there are two attributes associates with the vertices (<code>age</code> and <code>col</code>) and one with the edges (<code>weight</code>).</p>
<p>As mentioned earlier, <code>vcount()</code> and <code>ecount()</code> are functionts that return the number of vertices and edges of our network:</p>
<div class="sourceCode" id="cb222"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb222-1"><a href="social-network-structure.html#cb222-1"></a><span class="kw">vcount</span>(net)</span></code></pre></div>
<pre><code>## [1] 10</code></pre>
<div class="sourceCode" id="cb224"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb224-1"><a href="social-network-structure.html#cb224-1"></a><span class="kw">ecount</span>(net)</span></code></pre></div>
<pre><code>## [1] 22</code></pre>
<p>Additional to these descriptive measures, there is a series of measures that can be calculated:</p>
<p>‘Diameter’ is a measure for the longest (geodesic) path, i.e. the largest number of steps that are necessary to reach two vertices in a network (using <code>farthest_vertices()</code> we can return the ID of the two vertices).</p>
<div class="sourceCode" id="cb226"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb226-1"><a href="social-network-structure.html#cb226-1"></a><span class="kw">diameter</span>(<span class="dt">graph =</span> net)</span></code></pre></div>
<pre><code>## [1] 0.8579902</code></pre>
<p>‘Average path length’ is the average number of steps that need to be traversed between any two vertices (aka as dyad). We can also use the <code>distance()</code> function to return a distance matrix similar to the adjacency matrix.</p>
<div class="sourceCode" id="cb228"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb228-1"><a href="social-network-structure.html#cb228-1"></a><span class="kw">mean_distance</span>(<span class="dt">graph =</span> net)</span></code></pre></div>
<pre><code>## [1] 1.533333</code></pre>
<p>‘Edge density’ is the proportion of edges present in the graph relative to the number of possible edges (i.e. in a fully connected network with the same number of nodes). This is one of the easier calculations, which we could alo write as <code>sum(adjm&gt;0) / (length(adjm)-ncol(adjm))</code> using our adjacency matrix.</p>
<div class="sourceCode" id="cb230"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb230-1"><a href="social-network-structure.html#cb230-1"></a><span class="kw">edge_density</span>(<span class="dt">graph =</span> net)</span></code></pre></div>
<pre><code>## [1] 0.4888889</code></pre>
<p>‘Reciprocity’ calculates the proportion of mutual edges relative to all existing edges. This is relevant for directed graphs. As we have an undirected graph, this value is one.</p>
<div class="sourceCode" id="cb232"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb232-1"><a href="social-network-structure.html#cb232-1"></a><span class="kw">reciprocity</span>(<span class="dt">graph =</span> net)</span></code></pre></div>
<pre><code>## [1] 1</code></pre>
<p>‘Clustering coefficient’ (also referred to as transitivity, or cliquishness) is the probability that the two neighbours of a vertex are neighbours of each other. This is also called a triangle. You can also imagine it as ‘my friends are friends with each other’.</p>
<div class="sourceCode" id="cb234"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb234-1"><a href="social-network-structure.html#cb234-1"></a><span class="kw">transitivity</span>(<span class="dt">graph =</span> net)</span></code></pre></div>
<pre><code>## [1] 0.4941176</code></pre>
</div>
<div id="vertex-properties" class="section level3">
<h3><span class="header-section-number">14.4.2</span> Vertex properties</h3>
<p>Additional to these high-level measures, we can use a series of vertex-level measures.</p>
<p>‘Degree centrality’ refers to the number of (incoming/outgoing/both) edges of a vertex. We can use the <code>degree()</code> function to determine the degree centrality of each node:</p>
<div class="sourceCode" id="cb236"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb236-1"><a href="social-network-structure.html#cb236-1"></a><span class="co"># Number of edges that connected with each node</span></span>
<span id="cb236-2"><a href="social-network-structure.html#cb236-2"></a><span class="kw">degree</span>(<span class="dt">graph =</span> net)</span></code></pre></div>
<pre><code>##  [1] 4 4 3 3 3 5 4 5 8 5</code></pre>
<div class="sourceCode" id="cb238"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb238-1"><a href="social-network-structure.html#cb238-1"></a><span class="co"># The mean of all degree centralities is a general measure of network connectivity</span></span>
<span id="cb238-2"><a href="social-network-structure.html#cb238-2"></a><span class="kw">mean</span>(<span class="kw">degree</span>(<span class="dt">graph =</span> net))</span></code></pre></div>
<pre><code>## [1] 4.4</code></pre>
<p>‘Strength’ is similar to degree centrality but relevant for weighted networks. It is the sum of all adjacent edge weights (a node might have many edges but with very low weights and so with high degree centrality but low strength). In the case of an unweighted network, <code>degree()</code> and <code>strength()</code> would return the same result.</p>
<div class="sourceCode" id="cb240"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb240-1"><a href="social-network-structure.html#cb240-1"></a><span class="kw">sort</span>(<span class="kw">strength</span>(<span class="dt">graph =</span> net))</span></code></pre></div>
<pre><code>##  [1] 0.8297982 0.9756037 1.0591974 1.2782146 2.0171875 2.1172293 2.1374791
##  [8] 2.2638108 2.2747887 2.3640184</code></pre>
<p>‘Closeness centrality’ represents the number of steps it takes from a given vertex to any other vertex in the network. It is a measure of how long information on average takes to arrive at this node.</p>
<div class="sourceCode" id="cb242"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb242-1"><a href="social-network-structure.html#cb242-1"></a><span class="kw">closeness</span>(<span class="dt">graph =</span> net)</span></code></pre></div>
<pre><code>##  [1] 0.2263152 0.2602427 0.1392872 0.2981830 0.2368820 0.2513048 0.2688231
##  [8] 0.2606125 0.3970498 0.2854259</code></pre>
<p>Note that the values are <span class="math inline">\(&lt;1\)</span>. This is because <code>igraph</code> defines closeness centrality as ‘the inverse of the average length of the shortest paths to/from all the other vertices in the graph.’</p>
<p>‘Betweenness centrality’ is the number of shortest paths between nodes that pass through a particular node. It is often seen as a measure for a node’s gatekeeping or brokerage potential:</p>
<div class="sourceCode" id="cb244"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb244-1"><a href="social-network-structure.html#cb244-1"></a><span class="kw">betweenness</span>(<span class="dt">graph =</span> net)</span></code></pre></div>
<pre><code>##  [1]  0  0  0  0  0  0  9 12 23 12</code></pre>
<p>‘Eigenvector centrality’ is the eigenvector of the adjacency matrix. Vertices with a high eigenvector centrality are connected to many individuals who are connected to many individuals, and so on (see also page rank, <code>page_rank()</code>, and authority, <code>authority_score()</code>, score functions).</p>
<div class="sourceCode" id="cb246"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb246-1"><a href="social-network-structure.html#cb246-1"></a><span class="kw">eigen_centrality</span>(<span class="dt">graph =</span> net)<span class="op">$</span>vector</span></code></pre></div>
<pre><code>##  [1] 0.9058493 1.0000000 0.9617587 0.2721398 0.2732112 0.6122256 0.5473525
##  [8] 0.7753766 0.7901045 0.4082803</code></pre>
<p>Sometimes it is good to visualise these characteristics as colour in your network. For example, betweenness centrality can be hard to see by just looking at the graph. Instead of plotting the age of our vertices, we could also plot their network metrics. Here is an example for colouring nodes based on their betweenness centrality. The closer to red colour, the more a node has higher betweenness centrality.</p>
<div class="sourceCode" id="cb248"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb248-1"><a href="social-network-structure.html#cb248-1"></a>between &lt;-<span class="st"> </span><span class="kw">betweenness</span>(<span class="dt">graph =</span> net)</span>
<span id="cb248-2"><a href="social-network-structure.html#cb248-2"></a>col &lt;-<span class="st"> </span><span class="kw">heat.colors</span>(<span class="dt">n =</span> <span class="kw">max</span>(between) <span class="op">+</span><span class="st"> </span><span class="dv">1</span>, <span class="dt">rev =</span> <span class="ot">TRUE</span>)[between <span class="op">+</span><span class="st"> </span><span class="dv">1</span>]</span>
<span id="cb248-3"><a href="social-network-structure.html#cb248-3"></a><span class="co"># Plot network with col</span></span>
<span id="cb248-4"><a href="social-network-structure.html#cb248-4"></a><span class="kw">plot</span>(net, </span>
<span id="cb248-5"><a href="social-network-structure.html#cb248-5"></a>     <span class="dt">vertex.color =</span> col, </span>
<span id="cb248-6"><a href="social-network-structure.html#cb248-6"></a>     <span class="dt">vertex.label =</span> <span class="ot">NA</span>,</span>
<span id="cb248-7"><a href="social-network-structure.html#cb248-7"></a>     <span class="dt">vertex.size =</span> <span class="dv">20</span>,</span>
<span id="cb248-8"><a href="social-network-structure.html#cb248-8"></a>     <span class="dt">edge.color =</span> <span class="st">&quot;black&quot;</span>,</span>
<span id="cb248-9"><a href="social-network-structure.html#cb248-9"></a>     <span class="dt">edge.width =</span> <span class="dv">1</span>,</span>
<span id="cb248-10"><a href="social-network-structure.html#cb248-10"></a>     <span class="dt">edge.arrow.size =</span> <span class="fl">0.5</span>,</span>
<span id="cb248-11"><a href="social-network-structure.html#cb248-11"></a>     <span class="dt">layout =</span> coords,</span>
<span id="cb248-12"><a href="social-network-structure.html#cb248-12"></a>     <span class="dt">main =</span> <span class="st">&quot;Betweenness centrality&quot;</span>)</span></code></pre></div>
<div class="figure"><span id="fig:14-33"></span>
<img src="IBM-cultevo_files/figure-html/14-33-1.png" alt="Example graph where nodes are coloured based on their betweenness centrality. " width="672" />
<p class="caption">
Figure 14.10: Example graph where nodes are coloured based on their betweenness centrality.
</p>
</div>
</div>
</div>
<div id="modelling-information-transmission-in-social-networks" class="section level2">
<h2><span class="header-section-number">14.5</span> Modelling information transmission in social networks</h2>
<p>Now that we know how to generate, plot, and analyse networks, we can move on to use them in a social learning context.</p>
<p>The diffusion of information in social networks differs from the diffusion in well-mixed populations (see our earlier chapters) in that the individual does only have access to the information of her direct network neighbours, i.e. those they share edges with. In comparison, in well-mixed populations (equivalent to a fully connected network) every individual is equally likely to interact with any other individual, and so has access to information from the entire population. Thus, when modelling transmission in social networks, we have to take into account that an individual can only sample from its social environment and not from the entire population (which we have done in the earlier chapters, like the biased and unbiased transmission). Instead, we have to simulate neighbourhood sampling for each node individually.</p>
<p>In this part of the chapter, we will first develop a function to simulate the spread of gossip in networks of varying degree centrality. This will give us a better understanding of the effect of edge density on the diffusion speed. This is a simple model that you can alter to test other network characteristics (e.g. diameter or betweenness centrality). With the second model, we will simulate different ways of information diffusion (i.e. simple versus complex contagion) and test how network transitivity and the mode of transmission interact.</p>
<div id="gossip-diffusion-in-networked-populations" class="section level3">
<h3><span class="header-section-number">14.5.1</span> Gossip diffusion in networked populations</h3>
<p>Let us develop a model that simulates the spread of gossip in a group of people. As before, we will assume that a proportion <span class="math inline">\(f\)</span> of the population are friends and thus share an (undirected) edge. Gossip can spread between connected individuals. Gossip spreads from individuals that have gossip to those who do not. Eventually, all individuals that are in some way connected to an individual with gossip will possess the gossip.</p>
<p>Which elements do we need for this model? First, we need to keep track which individual has previously received the gossip (we will use a vector called <code>gossip</code> of length <span class="math inline">\(N\)</span> where <code>TRUE</code> indicates the possession of gossip). Second, we need an adjacency matrix that describes the connections in our network (this is stored in <code>adjm</code> and created using the <code>create_network()</code> function that we set up earlier in this chapter). Third, we will need a reporting variable to keep track how the proportion of the population in possession of gossip changes over time. This can be a simple vector of length <code>r_max</code>, i.e. the number of rounds. We will call this reporting vector <code>proportion</code>. And finally, we need a simulation loop that executed the following three steps:</p>
<ol style="list-style-type: decimal">
<li>In random sequence go through all individuals</li>
<li>If the focal individual has at least one neighbour, select one random neighbour</li>
<li>If that neighbour has gossip, change the focal individual’s gossip indicator to <code>TRUE</code></li>
</ol>
<p>We repeat these steps for <code>r_max</code> number of rounds. At the end of all rounds, we return a <code>tibble</code> where we will store the proportion of the population with gossip at each round, as well as the value of <span class="math inline">\(f\)</span> and the <code>sim</code> argument. This is the counter of our simulation. At the moment we only run one simulation at a time, so we set this argument to be one, i.e. <code>sim = 1</code> in the function definition. We will see that this counter can be useful when we run repeated simulations later.</p>
<div class="sourceCode" id="cb249"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb249-1"><a href="social-network-structure.html#cb249-1"></a><span class="kw">library</span>(tidyverse)</span>
<span id="cb249-2"><a href="social-network-structure.html#cb249-2"></a>gossip_model &lt;-<span class="st"> </span><span class="cf">function</span>(N, f, r_max, <span class="dt">sim =</span> <span class="dv">1</span>){</span>
<span id="cb249-3"><a href="social-network-structure.html#cb249-3"></a>  <span class="co"># Create a vector indicating possession of gossip and set one entry to TRUE</span></span>
<span id="cb249-4"><a href="social-network-structure.html#cb249-4"></a>  gossip &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="ot">FALSE</span>, N)</span>
<span id="cb249-5"><a href="social-network-structure.html#cb249-5"></a>  gossip[<span class="kw">sample</span>(<span class="dt">x =</span> N, <span class="dt">size =</span> <span class="dv">1</span>)] &lt;-<span class="st"> </span><span class="ot">TRUE</span></span>
<span id="cb249-6"><a href="social-network-structure.html#cb249-6"></a>  <span class="co"># Create a network</span></span>
<span id="cb249-7"><a href="social-network-structure.html#cb249-7"></a>  adjm &lt;-<span class="st"> </span><span class="kw">create_network</span>(<span class="dt">N =</span> N, <span class="dt">f =</span> f)</span>
<span id="cb249-8"><a href="social-network-structure.html#cb249-8"></a>  <span class="co"># Create a reporting variable</span></span>
<span id="cb249-9"><a href="social-network-structure.html#cb249-9"></a>  proportion &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>, r_max)</span>
<span id="cb249-10"><a href="social-network-structure.html#cb249-10"></a></span>
<span id="cb249-11"><a href="social-network-structure.html#cb249-11"></a>  <span class="co"># Loop over r_max rounds</span></span>
<span id="cb249-12"><a href="social-network-structure.html#cb249-12"></a>  <span class="cf">for</span>(r <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>r_max){</span>
<span id="cb249-13"><a href="social-network-structure.html#cb249-13"></a>    <span class="co"># In random sequence go through all individuals </span></span>
<span id="cb249-14"><a href="social-network-structure.html#cb249-14"></a>    <span class="cf">for</span>(i <span class="cf">in</span> <span class="kw">sample</span>(N)){</span>
<span id="cb249-15"><a href="social-network-structure.html#cb249-15"></a>      <span class="co"># Select i&#39;s neighbourhood</span></span>
<span id="cb249-16"><a href="social-network-structure.html#cb249-16"></a>      nei &lt;-<span class="st"> </span>adjm[i,] <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span></span>
<span id="cb249-17"><a href="social-network-structure.html#cb249-17"></a>      <span class="co"># Proceed if there is at least one neighbour</span></span>
<span id="cb249-18"><a href="social-network-structure.html#cb249-18"></a>      <span class="cf">if</span>(<span class="kw">sum</span>(nei) <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>){</span>
<span id="cb249-19"><a href="social-network-structure.html#cb249-19"></a>        <span class="co"># Choose one random neighbour, j</span></span>
<span id="cb249-20"><a href="social-network-structure.html#cb249-20"></a>        j &lt;-<span class="st"> </span><span class="kw">sampling</span>(<span class="dt">x =</span> <span class="kw">which</span>(nei), <span class="dt">size =</span> <span class="dv">1</span>)</span>
<span id="cb249-21"><a href="social-network-structure.html#cb249-21"></a>        <span class="co"># Set i&#39;s gossip indicator to TRUE if j&#39;s indicator is TRUE</span></span>
<span id="cb249-22"><a href="social-network-structure.html#cb249-22"></a>        <span class="cf">if</span>(gossip[j]){</span>
<span id="cb249-23"><a href="social-network-structure.html#cb249-23"></a>          gossip[i] &lt;-<span class="st"> </span><span class="ot">TRUE</span></span>
<span id="cb249-24"><a href="social-network-structure.html#cb249-24"></a>        }</span>
<span id="cb249-25"><a href="social-network-structure.html#cb249-25"></a>      }</span>
<span id="cb249-26"><a href="social-network-structure.html#cb249-26"></a>    }</span>
<span id="cb249-27"><a href="social-network-structure.html#cb249-27"></a>    <span class="co"># Record proportion of the population with gossip</span></span>
<span id="cb249-28"><a href="social-network-structure.html#cb249-28"></a>    proportion[r] &lt;-<span class="st"> </span><span class="kw">sum</span>(gossip) <span class="op">/</span><span class="st"> </span>N</span>
<span id="cb249-29"><a href="social-network-structure.html#cb249-29"></a>    <span class="co"># Increment the round counter</span></span>
<span id="cb249-30"><a href="social-network-structure.html#cb249-30"></a>    r &lt;-<span class="st"> </span>r <span class="op">+</span><span class="st"> </span><span class="dv">1</span></span>
<span id="cb249-31"><a href="social-network-structure.html#cb249-31"></a>  }</span>
<span id="cb249-32"><a href="social-network-structure.html#cb249-32"></a>  <span class="co"># Return a tibble with simulation results</span></span>
<span id="cb249-33"><a href="social-network-structure.html#cb249-33"></a>  <span class="kw">return</span>(<span class="kw">tibble</span>(<span class="dt">time =</span> <span class="dv">1</span><span class="op">:</span>r_max, <span class="dt">proportion =</span> proportion, <span class="dt">f =</span> f, <span class="dt">sim =</span> sim))</span>
<span id="cb249-34"><a href="social-network-structure.html#cb249-34"></a>}</span></code></pre></div>
<p>Going through this function, you will find two functions that are not part of R. The first is <code>create_network()</code>, which we created earlier. The second one is called <code>sampling()</code>. This is a wrapper function for the generic <code>sample()</code> function. What we want the sample function to do is to return one random value of a vector <span class="math inline">\(x\)</span> of length <span class="math inline">\(n\)</span>. This works well as long as <span class="math inline">\(n&gt;1\)</span>. If <span class="math inline">\(n=1\)</span>, i.e. if we pass to <code>sample()</code> a single number, we would expect <code>sample(x)</code> to return <code>x</code>. However, what you will find if you try this is that <code>sample()</code> will return a random sequence of the values <code>1:x</code>. So, if <code>x = 5</code>, <code>sample(x)</code> will return e.g. 3, 2, 1, 4, 5. What we could do to receive the desired outcome is to write a function that returns <code>x</code> whenever <span class="math inline">\(n=1\)</span> and in all other cases uses the <code>sample()</code> function. This function could look like the following:</p>
<div class="sourceCode" id="cb250"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb250-1"><a href="social-network-structure.html#cb250-1"></a>sampling &lt;-<span class="st"> </span><span class="cf">function</span>(x, <span class="dt">size =</span> <span class="kw">length</span>(x), <span class="dt">prob =</span> <span class="ot">NULL</span>){</span>
<span id="cb250-2"><a href="social-network-structure.html#cb250-2"></a>  <span class="cf">if</span>(<span class="kw">length</span>(x) <span class="op">==</span><span class="st"> </span><span class="dv">1</span>){</span>
<span id="cb250-3"><a href="social-network-structure.html#cb250-3"></a>    <span class="kw">return</span>(x)</span>
<span id="cb250-4"><a href="social-network-structure.html#cb250-4"></a>  } <span class="cf">else</span> {</span>
<span id="cb250-5"><a href="social-network-structure.html#cb250-5"></a>    <span class="kw">return</span>(<span class="kw">sample</span>(<span class="dt">x =</span> x, <span class="dt">size =</span> size, <span class="dt">prob =</span> prob))</span>
<span id="cb250-6"><a href="social-network-structure.html#cb250-6"></a>  }</span>
<span id="cb250-7"><a href="social-network-structure.html#cb250-7"></a>}</span></code></pre></div>
<p>We can now run our simulations for networks with different degree centrality. We will vary the average number of friends an individual has in the population. If there are <span class="math inline">\(N\)</span> individuals and an individual has on average two friends then the probability of two individuals sharing an edge is <span class="math inline">\(f=2/N\)</span>, and so on.</p>
<div class="sourceCode" id="cb251"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb251-1"><a href="social-network-structure.html#cb251-1"></a>N &lt;-<span class="st"> </span><span class="dv">1000</span></span>
<span id="cb251-2"><a href="social-network-structure.html#cb251-2"></a><span class="kw">set.seed</span>(<span class="dv">3</span>)</span>
<span id="cb251-3"><a href="social-network-structure.html#cb251-3"></a>data &lt;-<span class="st"> </span><span class="kw">lapply</span>(<span class="dt">X =</span> <span class="kw">c</span>(<span class="dv">1</span><span class="op">/</span>N, <span class="dv">2</span><span class="op">/</span>N, <span class="dv">3</span><span class="op">/</span>N, <span class="dv">5</span><span class="op">/</span>N, <span class="dv">8</span><span class="op">/</span>N, <span class="dv">10</span><span class="op">/</span>N), </span>
<span id="cb251-4"><a href="social-network-structure.html#cb251-4"></a>              <span class="dt">FUN =</span> <span class="cf">function</span>(f) <span class="kw">gossip_model</span>(<span class="dt">N =</span> N, <span class="dt">f =</span> f, <span class="dt">r_max =</span> <span class="dv">50</span>))</span>
<span id="cb251-5"><a href="social-network-structure.html#cb251-5"></a>data_bnd &lt;-<span class="st"> </span><span class="kw">bind_rows</span>(data)</span></code></pre></div>
<p>As in the <a href="demography.html#demography">previous chapter</a>, we use the <code>lapply()</code> function to run several independent simulations. The resulting <code>data</code> object is a list of tibbles. It is easier to plot the results if we could stack them all on top of each other into a single large tibble. We can do this using the <code>bind_rows()</code> function.</p>
<p>Also note the use of the <code>set.seed()</code> function here (and in some of the following simulations). This function affects how your computer generates random numbers. For example, repeatedly running <code>runif(1)</code> will draw a different number from a uniform distribution every time. However, if we repeatedly run <code>set.seed(1); runif(1)</code> we will always receive the same number. By setting a seed we can recover the same (pseudo) random process between different executions. Due to the stochastic nature of our simulations, results might look different between different runs. And so, for illustrative purposes we use a seed here.</p>
<p>We now can use a simple <code>ggplot()</code> line plot to see how the frequency of gossip in populations with different degree centrality changes over time:</p>
<div class="sourceCode" id="cb252"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb252-1"><a href="social-network-structure.html#cb252-1"></a><span class="kw">ggplot</span>(data_bnd) <span class="op">+</span><span class="st"> </span></span>
<span id="cb252-2"><a href="social-network-structure.html#cb252-2"></a><span class="st">  </span><span class="kw">geom_line</span>(<span class="kw">aes</span>(<span class="dt">x =</span> time, <span class="dt">y =</span> proportion, <span class="dt">col =</span> <span class="kw">factor</span>(<span class="kw">round</span>(f <span class="op">*</span><span class="st"> </span>N)))) <span class="op">+</span><span class="st"> </span></span>
<span id="cb252-3"><a href="social-network-structure.html#cb252-3"></a><span class="st">  </span><span class="kw">ylab</span>(<span class="st">&quot;proportion of individuals with gossip&quot;</span>) <span class="op">+</span></span>
<span id="cb252-4"><a href="social-network-structure.html#cb252-4"></a><span class="st">  </span><span class="kw">labs</span>(<span class="dt">col =</span> <span class="st">&quot;average number of friends&quot;</span>) <span class="op">+</span></span>
<span id="cb252-5"><a href="social-network-structure.html#cb252-5"></a><span class="st">  </span><span class="kw">theme_bw</span>()</span></code></pre></div>
<div class="figure"><span id="fig:14-37"></span>
<img src="IBM-cultevo_files/figure-html/14-37-1.png" alt="Gossip spreads first quickly and then more slowly throughout a population." width="672" />
<p class="caption">
Figure 14.11: Gossip spreads first quickly and then more slowly throughout a population.
</p>
</div>
<p>We can see that there is a big difference between 1 and 2 friends on average but very small between 8 and 10. It is also good to see that 50 turns are sufficient for our system to reach an equilibrium.</p>
<p>We should run the simulation more than once and average the results. That way, we can say more definitely how average degree affects the speed and level of spread. We can also measure how long it takes for some gossip to spread in more than, say, <span class="math inline">\(75\%\)</span> of the population. Again, we will use an <code>lapply()</code> function to run our simulations. Note that this time, we use an indicator <code>i</code> to number the current simulation run (by setting <code>sim = i</code>). This way, we can keep the results from repeated simulation runs with the same starting parameters separate from each other.</p>
<div class="sourceCode" id="cb253"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb253-1"><a href="social-network-structure.html#cb253-1"></a>N &lt;-<span class="st"> </span><span class="dv">100</span></span>
<span id="cb253-2"><a href="social-network-structure.html#cb253-2"></a>f &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="kw">c</span>(<span class="dv">1</span><span class="op">/</span>N, <span class="dv">2</span><span class="op">/</span>N, <span class="dv">3</span><span class="op">/</span>N, <span class="dv">5</span><span class="op">/</span>N, <span class="dv">8</span><span class="op">/</span>N, <span class="dv">10</span><span class="op">/</span>N), <span class="dt">each =</span> <span class="dv">10</span>)</span>
<span id="cb253-3"><a href="social-network-structure.html#cb253-3"></a></span>
<span id="cb253-4"><a href="social-network-structure.html#cb253-4"></a><span class="kw">set.seed</span>(<span class="dv">5</span>)</span>
<span id="cb253-5"><a href="social-network-structure.html#cb253-5"></a>data &lt;-<span class="st"> </span><span class="kw">lapply</span>(<span class="dt">X =</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(f), </span>
<span id="cb253-6"><a href="social-network-structure.html#cb253-6"></a>              <span class="dt">FUN =</span> <span class="cf">function</span>(i) <span class="kw">gossip_model</span>(<span class="dt">N =</span> N, <span class="dt">f =</span> f[i], <span class="dt">r_max =</span> <span class="dv">50</span>, <span class="dt">sim =</span> i))</span></code></pre></div>
<p>Now we bind the resulting tibbles into a single object and plot the simulation results. Note that we are now using the <code>sim</code> counter as input for the <code>group</code> argument in <code>geom_line()</code>. This tells <code>ggplot</code> to draw a line only between those points that belong to the same group, i.e. the same simulation run:</p>
<div class="sourceCode" id="cb254"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb254-1"><a href="social-network-structure.html#cb254-1"></a>data_bnd &lt;-<span class="st"> </span><span class="kw">bind_rows</span>(data)</span>
<span id="cb254-2"><a href="social-network-structure.html#cb254-2"></a><span class="kw">ggplot</span>(data_bnd) <span class="op">+</span></span>
<span id="cb254-3"><a href="social-network-structure.html#cb254-3"></a><span class="st">  </span><span class="kw">geom_line</span>(<span class="kw">aes</span>(<span class="dt">x =</span> time, <span class="dt">y =</span> proportion, <span class="dt">col =</span> <span class="kw">factor</span>(f <span class="op">*</span><span class="st"> </span>N), <span class="dt">group =</span> <span class="kw">factor</span>(sim))) <span class="op">+</span><span class="st"> </span></span>
<span id="cb254-4"><a href="social-network-structure.html#cb254-4"></a><span class="st">  </span><span class="kw">ylab</span>(<span class="st">&quot;proportion of individual with gossip&quot;</span>) <span class="op">+</span></span>
<span id="cb254-5"><a href="social-network-structure.html#cb254-5"></a><span class="st">  </span><span class="kw">labs</span>(<span class="dt">col =</span> <span class="st">&quot;average number of friends&quot;</span>) <span class="op">+</span></span>
<span id="cb254-6"><a href="social-network-structure.html#cb254-6"></a><span class="st">  </span><span class="kw">theme_bw</span>()</span></code></pre></div>
<div class="figure"><span id="fig:14-39"></span>
<img src="IBM-cultevo_files/figure-html/14-39-1.png" alt="Repeated runs of `gossip_model()` show that on average gossip spreads to less than $0.2$ of the population if individuals have on average 1 friend. For 2 and more friends gossip spreads to more than three quarter of the population." width="672" />
<p class="caption">
Figure 14.12: Repeated runs of <code>gossip_model()</code> show that on average gossip spreads to less than <span class="math inline">\(0.2\)</span> of the population if individuals have on average 1 friend. For 2 and more friends gossip spreads to more than three quarter of the population.
</p>
</div>
<p>As you can see, each simulation run is a bit different even of they have the same starting parameter. Let us plot the proportion of population with gossip in the last simulation step for each degree centrality:</p>
<div class="sourceCode" id="cb255"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb255-1"><a href="social-network-structure.html#cb255-1"></a>data_bnd_last &lt;-<span class="st"> </span>data_bnd[data_bnd<span class="op">$</span>time <span class="op">==</span><span class="st"> </span><span class="kw">max</span>(data_bnd<span class="op">$</span>time), ]</span>
<span id="cb255-2"><a href="social-network-structure.html#cb255-2"></a><span class="kw">ggplot</span>(data_bnd_last) <span class="op">+</span><span class="st"> </span></span>
<span id="cb255-3"><a href="social-network-structure.html#cb255-3"></a><span class="st">  </span><span class="kw">geom_boxplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> <span class="kw">factor</span>(f <span class="op">*</span><span class="st"> </span>N), <span class="dt">y =</span> proportion)) <span class="op">+</span><span class="st"> </span></span>
<span id="cb255-4"><a href="social-network-structure.html#cb255-4"></a><span class="st">  </span><span class="kw">xlab</span>(<span class="st">&quot;average number of friends&quot;</span>) <span class="op">+</span></span>
<span id="cb255-5"><a href="social-network-structure.html#cb255-5"></a><span class="st">  </span><span class="kw">ylab</span>(<span class="st">&quot;proportion of individuals with gossip&quot;</span>) <span class="op">+</span><span class="st"> </span></span>
<span id="cb255-6"><a href="social-network-structure.html#cb255-6"></a><span class="st">  </span><span class="kw">theme_bw</span>()</span></code></pre></div>
<div class="figure"><span id="fig:14-40"></span>
<img src="IBM-cultevo_files/figure-html/14-40-1.png" alt="Here we plot the end points of each simulation from the previous plot as a boxplot. This, again, shows that there is a dramatic difference of diffusion in networks with 1 to 3 friends, but far less in those with 5 and more friends." width="672" />
<p class="caption">
Figure 14.13: Here we plot the end points of each simulation from the previous plot as a boxplot. This, again, shows that there is a dramatic difference of diffusion in networks with 1 to 3 friends, but far less in those with 5 and more friends.
</p>
</div>
<p>You can see that as the number of friends increase a larger proportion of the population will have gossip after 50 simulation rounds. The increase is very strong initially and then levels off quickly after an average degree of 3.</p>
<p>Another metric we can look at is the number of rounds until <span class="math inline">\(75\%\)</span> of the population own gossip. For this, we will go through each simulation run, that is, each list element stored in <code>data</code>, and select the first timestep where <code>proportion &gt;= 0.75</code>. Note that some simulations do not reach this <span class="math inline">\(75\%\)</span> and the resulting value will be <code>NA</code>. One way to deal with these is to disregard these simulations. Another one is to set all <code>NA</code> values to <code>r_max</code>, in our case 50, as we will do here.</p>
<div class="sourceCode" id="cb256"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb256-1"><a href="social-network-structure.html#cb256-1"></a>data_bnd_time &lt;-<span class="st"> </span><span class="kw">lapply</span>(data, <span class="cf">function</span>(dat){</span>
<span id="cb256-2"><a href="social-network-structure.html#cb256-2"></a>  <span class="kw">tibble</span>(dat[<span class="dv">1</span>,], <span class="dt">time_to_x =</span> <span class="kw">which</span>(dat[,<span class="st">&quot;proportion&quot;</span>] <span class="op">&gt;=</span><span class="st"> </span><span class="fl">0.75</span>)[<span class="dv">1</span>])</span>
<span id="cb256-3"><a href="social-network-structure.html#cb256-3"></a>}) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">bind_rows</span>()</span>
<span id="cb256-4"><a href="social-network-structure.html#cb256-4"></a></span>
<span id="cb256-5"><a href="social-network-structure.html#cb256-5"></a>data_bnd_time<span class="op">$</span>time_to_x[<span class="kw">is.na</span>(data_bnd_time<span class="op">$</span>time_to_x)] &lt;-<span class="st"> </span><span class="dv">50</span></span>
<span id="cb256-6"><a href="social-network-structure.html#cb256-6"></a></span>
<span id="cb256-7"><a href="social-network-structure.html#cb256-7"></a><span class="kw">ggplot</span>(data_bnd_time) <span class="op">+</span><span class="st"> </span></span>
<span id="cb256-8"><a href="social-network-structure.html#cb256-8"></a><span class="st">  </span><span class="kw">geom_boxplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> <span class="kw">factor</span>(f <span class="op">*</span><span class="st"> </span>N), <span class="dt">y =</span> time_to_x)) <span class="op">+</span><span class="st"> </span></span>
<span id="cb256-9"><a href="social-network-structure.html#cb256-9"></a><span class="st">  </span><span class="kw">xlab</span>(<span class="st">&quot;average number of friends&quot;</span>) <span class="op">+</span></span>
<span id="cb256-10"><a href="social-network-structure.html#cb256-10"></a><span class="st">  </span><span class="kw">ylab</span>(<span class="st">&quot;time to spread to 75% of population&quot;</span>) <span class="op">+</span></span>
<span id="cb256-11"><a href="social-network-structure.html#cb256-11"></a><span class="st">  </span><span class="kw">theme_bw</span>()</span></code></pre></div>
<div class="figure"><span id="fig:14-41"></span>
<img src="IBM-cultevo_files/figure-html/14-41-1.png" alt="Speed at which gossip spreads depending on the average number of friends." width="672" />
<p class="caption">
Figure 14.14: Speed at which gossip spreads depending on the average number of friends.
</p>
</div>
<p>Now we can say that with more friends, information (or gossip) does not only spread to larger proportions of a population but it does so faster. This is true for the random networks that we have tested here. However, as mentioned earlier, there are many different network categories that differ in degree distribution, average path length, clustering, and others. With the next model, we will take a closer look at the effect of clustering.</p>
</div>
<div id="complex-versus-simple-contagion-information-transmission" class="section level3">
<h3><span class="header-section-number">14.5.2</span> Complex versus simple contagion information transmission</h3>
<p>Another factor that affects the spread of information in networks is the mode of information transmission. That is, often information is not transmitted from one individual to another in a simple contagion-like manner, where exposure to one informed individual is sufficient, but instead requires increased social facilitation. In other words, often we are more likely to acquire behaviours from others if this behaviour is more frequent in our neighbourhood. This kind of transmission is called ‘complex contagion’. A study on the spread of health behaviour reported that a new behaviour spread faster in clustered than in random networks (<span class="citation">Centola (<a href="references.html#ref-centola_spread_2010" role="doc-biblioref">2010</a>)</span>). The author explained the result by pointing to the increased social feedback a focal individual can receive in clustered networks, where neighbours are more likely also neighbours with each other, as compared to random networks. Let us model complex contagion to better understand how the mode of transmission affects the speed of diffusion in different networks.</p>
<p>In the previous iteration of <code>gossip_model()</code>, we selected a random neighbour, <span class="math inline">\(j\)</span>, of a focal individual <span class="math inline">\(i\)</span>. If <span class="math inline">\(j\)</span> had gossip then <span class="math inline">\(i\)</span> acquired the gossip with certainty. For example, if <span class="math inline">\(i\)</span> had 3 neighbours of which only one had gossip, his probability to acquire gossip within the next round, <span class="math inline">\(p_g\)</span>, was <span class="math inline">\(1/3\)</span>, as there is a 1 in 3 chance that we randomly pick the neighbour with gossip. So, instead of writing:</p>
<div class="sourceCode" id="cb257"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb257-1"><a href="social-network-structure.html#cb257-1"></a>j &lt;-<span class="st"> </span><span class="kw">sampling</span>(<span class="dt">x =</span> <span class="kw">which</span>(nei), <span class="dt">size =</span> <span class="dv">1</span>)</span>
<span id="cb257-2"><a href="social-network-structure.html#cb257-2"></a><span class="cf">if</span>(gossip[j]){</span>
<span id="cb257-3"><a href="social-network-structure.html#cb257-3"></a>  gossip[i] &lt;-<span class="st"> </span><span class="ot">TRUE</span></span>
<span id="cb257-4"><a href="social-network-structure.html#cb257-4"></a>}</span></code></pre></div>
<p>We could also write:</p>
<div class="sourceCode" id="cb258"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb258-1"><a href="social-network-structure.html#cb258-1"></a>p_g &lt;-<span class="st"> </span><span class="kw">sum</span>(gossip <span class="op">*</span><span class="st"> </span>nei) <span class="op">/</span><span class="st"> </span><span class="kw">length</span>(nei)</span>
<span id="cb258-2"><a href="social-network-structure.html#cb258-2"></a><span class="cf">if</span>(<span class="kw">runif</span>(<span class="dt">n =</span> <span class="dv">1</span>, <span class="dt">min =</span> <span class="dv">0</span>, <span class="dt">max =</span> <span class="dv">1</span>) <span class="op">&lt;=</span><span class="st"> </span>p_g){</span>
<span id="cb258-3"><a href="social-network-structure.html#cb258-3"></a>  gossip[i] &lt;-<span class="st"> </span><span class="ot">TRUE</span></span>
<span id="cb258-4"><a href="social-network-structure.html#cb258-4"></a>}</span></code></pre></div>
<p>Here, the <code>if</code> statement is true if a value that is randomly drawn from a uniform distribution (that is what <code>runif()</code> is doing), is smaller or equal to the probability to encounter an individual with gossip, <span class="math inline">\(p_g\)</span> (i.e. number of neighbours with gossip, <code>sum(gossip * nei)</code>, divided by the number of neighbours, <code>length(nei)</code>). Note that <code>gossip * nei</code> returns a boolean vector that is only <code>TRUE</code> for individuals that are both a neighbour and have gossip. As you can see, the probability that <span class="math inline">\(i\)</span> acquires gossip scales linearly with the proportion of neighbours with gossip. This is a good approximation for the spread of information following simple contagion.</p>
<p>In the case of complex contagion, instead, we assume that occasional interactions (or exposures) are less important than more frequent ones. We might require an individual to be exposed to gossip repeatedly. This could be, say, the repeated encounter with a gossiper or encounter of more than one gossiper. We can then write:</p>
<div class="sourceCode" id="cb259"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb259-1"><a href="social-network-structure.html#cb259-1"></a><span class="cf">if</span>(<span class="kw">runif</span>(<span class="dt">n =</span> <span class="dv">1</span>, <span class="dt">min =</span> <span class="dv">0</span>, <span class="dt">max =</span> <span class="dv">1</span>) <span class="op">&lt;=</span><span class="st"> </span>(<span class="kw">sum</span>(nei) <span class="op">/</span><span class="st"> </span><span class="kw">length</span>(nei))<span class="op">^</span>e){</span>
<span id="cb259-2"><a href="social-network-structure.html#cb259-2"></a>  gossip[i] &lt;-<span class="st"> </span><span class="ot">TRUE</span></span>
<span id="cb259-3"><a href="social-network-structure.html#cb259-3"></a>}</span></code></pre></div>
<p>where the exponent <code>e</code> affects the shape of the function that describes the probability to acquire gossip:</p>
<div class="sourceCode" id="cb260"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb260-1"><a href="social-network-structure.html#cb260-1"></a>prop_nei_info &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dt">from =</span> <span class="dv">0</span>, <span class="dt">to =</span> <span class="dv">1</span>, <span class="dt">length.out =</span> <span class="dv">10</span>)</span>
<span id="cb260-2"><a href="social-network-structure.html#cb260-2"></a>e &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>)</span>
<span id="cb260-3"><a href="social-network-structure.html#cb260-3"></a>contagion &lt;-<span class="st"> </span><span class="kw">tibble</span>(</span>
<span id="cb260-4"><a href="social-network-structure.html#cb260-4"></a>  <span class="dt">contagion =</span> <span class="kw">rep</span>(<span class="kw">c</span>(<span class="st">&quot;simple&quot;</span>, <span class="st">&quot;complex&quot;</span>), <span class="dt">each =</span> <span class="dv">10</span>),</span>
<span id="cb260-5"><a href="social-network-structure.html#cb260-5"></a>  <span class="dt">x =</span> <span class="kw">rep</span>(prop_nei_info, <span class="dv">2</span>), </span>
<span id="cb260-6"><a href="social-network-structure.html#cb260-6"></a>  <span class="dt">y =</span> <span class="kw">c</span>(prop_nei_info<span class="op">^</span>e[<span class="dv">1</span>], prop_nei_info<span class="op">^</span>e[<span class="dv">2</span>]))</span>
<span id="cb260-7"><a href="social-network-structure.html#cb260-7"></a></span>
<span id="cb260-8"><a href="social-network-structure.html#cb260-8"></a><span class="kw">ggplot</span>(contagion, <span class="kw">aes</span>(<span class="dt">x =</span> x, <span class="dt">y =</span> y, <span class="dt">col =</span> contagion)) <span class="op">+</span><span class="st"> </span></span>
<span id="cb260-9"><a href="social-network-structure.html#cb260-9"></a><span class="st">  </span><span class="kw">geom_point</span>() <span class="op">+</span></span>
<span id="cb260-10"><a href="social-network-structure.html#cb260-10"></a><span class="st">  </span><span class="kw">geom_line</span>() <span class="op">+</span></span>
<span id="cb260-11"><a href="social-network-structure.html#cb260-11"></a><span class="st">  </span><span class="kw">xlab</span>(<span class="st">&quot;proportion of neighbours with gossip&quot;</span>) <span class="op">+</span><span class="st"> </span></span>
<span id="cb260-12"><a href="social-network-structure.html#cb260-12"></a><span class="st">  </span><span class="kw">ylab</span>(<span class="st">&quot;probability to acquire gossip&quot;</span>) <span class="op">+</span></span>
<span id="cb260-13"><a href="social-network-structure.html#cb260-13"></a><span class="st">  </span><span class="kw">theme_bw</span>()</span></code></pre></div>
<div class="figure"><span id="fig:14-45"></span>
<img src="IBM-cultevo_files/figure-html/14-45-1.png" alt="In simple contagion the probability to acquire gossip scales linearly with the proportion of neighbours with gossip, whereas it increases superlinearly (here exponentially) in the case of complex contagion." width="672" />
<p class="caption">
Figure 14.15: In simple contagion the probability to acquire gossip scales linearly with the proportion of neighbours with gossip, whereas it increases superlinearly (here exponentially) in the case of complex contagion.
</p>
</div>
<p>The figure shows that in the case of simple contagion (<span class="math inline">\(e=1\)</span>), the probability to acquire gossip increases linearly with the proportion of gossiping neighbours. For complex contagion (e.g. <span class="math inline">\(e=2\)</span>), however, acquisition increases exponentially.</p>
<p>Let us test whether we can simulate the empirical results from the study we mentioned earlier, i.e. that information spreading in a complex contagion-like manner spreads faster in clustered networks. To simulate networks that are as close as possible to the ones used by <span class="citation">Centola (<a href="references.html#ref-centola_spread_2010" role="doc-biblioref">2010</a>)</span> we will use the <code>make_lattice()</code> function in igraph. The function sets up simple lattice graphs of varying dimensions and lengths along each dimension. In our case, we want a two-dimensional graph, of 100 individuals, and a neighbourhood size of two, i.e. an individual is not only connected to the direct neighbours in a square lattice but also the direct neighbour of each of their neighbours. Additionally, we set the <code>circular</code> argument to be true. This connects the nodes of one edge of the lattice with the nodes on the opposite side. The resulting graph looks like a torus.</p>
<div class="sourceCode" id="cb261"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb261-1"><a href="social-network-structure.html#cb261-1"></a>net_clust &lt;-<span class="st"> </span><span class="kw">make_lattice</span>(<span class="dt">length =</span> <span class="dv">10</span>, <span class="dt">dim =</span> <span class="dv">2</span>, <span class="dt">circular =</span> T, <span class="dt">nei =</span> <span class="dv">2</span>)</span></code></pre></div>
<p>This is a regular graph (i.e. each neighbourhood looks the same). We can use the <code>rewire()</code> function to turn it into a random graph. In combination with <code>keeping_degseq()</code>, the function will take two random edges (say between nodes A, B and C,D) and rewire them (to A,D and C,B). This shuffling will reduce the clustering but keep the degree of each node the same. This is good because we do not want to change too many characteristics of the network, which would make it more complicated to explain differences in the simulation results.</p>
<div class="sourceCode" id="cb262"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb262-1"><a href="social-network-structure.html#cb262-1"></a>net_rand &lt;-<span class="st"> </span><span class="kw">rewire</span>(<span class="dt">graph =</span> net_clust, <span class="dt">with =</span> <span class="kw">keeping_degseq</span>(<span class="dt">loops =</span> F, <span class="dt">niter =</span> <span class="dv">10</span><span class="op">^</span><span class="dv">3</span>))</span></code></pre></div>
<p>Let us have a look at the network characteristics of the clustered and the random network:</p>
<div class="sourceCode" id="cb263"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb263-1"><a href="social-network-structure.html#cb263-1"></a><span class="kw">head</span>(<span class="kw">degree</span>(net_clust))</span></code></pre></div>
<pre><code>## [1] 12 12 12 12 12 12</code></pre>
<div class="sourceCode" id="cb265"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb265-1"><a href="social-network-structure.html#cb265-1"></a><span class="kw">head</span>(<span class="kw">degree</span>(net_rand))</span></code></pre></div>
<pre><code>## [1] 12 12 12 12 12 12</code></pre>
<div class="sourceCode" id="cb267"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb267-1"><a href="social-network-structure.html#cb267-1"></a><span class="kw">transitivity</span>(net_clust)</span></code></pre></div>
<pre><code>## [1] 0.4545455</code></pre>
<div class="sourceCode" id="cb269"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb269-1"><a href="social-network-structure.html#cb269-1"></a><span class="kw">transitivity</span>(net_rand)</span></code></pre></div>
<pre><code>## [1] 0.09818182</code></pre>
<p>While the degree centrality remains unchanged, the clustering coefficient of the random network is only about a quarter of the lattice network. We will use these two networks in the following simulations.</p>
<p>Now that we have the networks, let us modify the <code>gossip_model()</code> function. We will change the function such that (1) we can hand over the network directly (<code>net</code> argument), (2) this network will be rewired if the additional argument <code>rewire</code> is set to <code>TRUE</code>, and (3) contagion can be simple or complex, which we will set with one more argument (<code>e</code>).</p>
<div class="sourceCode" id="cb271"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb271-1"><a href="social-network-structure.html#cb271-1"></a>gossip_model_<span class="dv">2</span> &lt;-<span class="st"> </span><span class="cf">function</span>(net, rewire, <span class="dt">e =</span> <span class="dv">1</span>, r_max, <span class="dt">sim =</span> <span class="dv">1</span>){</span>
<span id="cb271-2"><a href="social-network-structure.html#cb271-2"></a>  <span class="co"># Rewire network if random is set to TRUE</span></span>
<span id="cb271-3"><a href="social-network-structure.html#cb271-3"></a>  <span class="cf">if</span>(rewire){</span>
<span id="cb271-4"><a href="social-network-structure.html#cb271-4"></a>    net &lt;-<span class="st"> </span><span class="kw">rewire</span>(<span class="dt">graph =</span> net, <span class="dt">with =</span> <span class="kw">keeping_degseq</span>(<span class="dt">loops =</span> F, <span class="dt">niter =</span> <span class="dv">10</span><span class="op">^</span><span class="dv">3</span>))</span>
<span id="cb271-5"><a href="social-network-structure.html#cb271-5"></a>  }</span>
<span id="cb271-6"><a href="social-network-structure.html#cb271-6"></a>  <span class="co"># Get adjacency matrix from network</span></span>
<span id="cb271-7"><a href="social-network-structure.html#cb271-7"></a>  adjm &lt;-<span class="st"> </span><span class="kw">get.adjacency</span>(net, <span class="dt">sparse =</span> F)</span>
<span id="cb271-8"><a href="social-network-structure.html#cb271-8"></a>  <span class="co"># Turn adjacency matrix into boolean (TRUE / FALSE)</span></span>
<span id="cb271-9"><a href="social-network-structure.html#cb271-9"></a>  adjm_bool &lt;-<span class="st"> </span>adjm <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span></span>
<span id="cb271-10"><a href="social-network-structure.html#cb271-10"></a>  <span class="co"># Set number of individuals based adjacency matrix</span></span>
<span id="cb271-11"><a href="social-network-structure.html#cb271-11"></a>  N &lt;-<span class="st"> </span><span class="kw">vcount</span>(net)</span>
<span id="cb271-12"><a href="social-network-structure.html#cb271-12"></a>  </span>
<span id="cb271-13"><a href="social-network-structure.html#cb271-13"></a>  <span class="co"># Create a vector indicating possession of gossip and set one entry to TRUE</span></span>
<span id="cb271-14"><a href="social-network-structure.html#cb271-14"></a>  gossip &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="ot">FALSE</span>, N)</span>
<span id="cb271-15"><a href="social-network-structure.html#cb271-15"></a>  gossip[<span class="kw">sample</span>(<span class="dt">x =</span> N, <span class="dt">size =</span> <span class="dv">1</span>)] &lt;-<span class="st"> </span><span class="ot">TRUE</span></span>
<span id="cb271-16"><a href="social-network-structure.html#cb271-16"></a>  </span>
<span id="cb271-17"><a href="social-network-structure.html#cb271-17"></a>  <span class="co"># Create a reporting variable</span></span>
<span id="cb271-18"><a href="social-network-structure.html#cb271-18"></a>  proportion &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>, r_max)</span>
<span id="cb271-19"><a href="social-network-structure.html#cb271-19"></a>  </span>
<span id="cb271-20"><a href="social-network-structure.html#cb271-20"></a>  <span class="co"># Rounds</span></span>
<span id="cb271-21"><a href="social-network-structure.html#cb271-21"></a>  <span class="cf">for</span>(r <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>r_max){</span>
<span id="cb271-22"><a href="social-network-structure.html#cb271-22"></a>    <span class="co"># In random sequence go through all individuals without gossip</span></span>
<span id="cb271-23"><a href="social-network-structure.html#cb271-23"></a>    <span class="cf">for</span>(i <span class="cf">in</span> <span class="kw">sample</span>(N)){</span>
<span id="cb271-24"><a href="social-network-structure.html#cb271-24"></a>      <span class="co"># Select i&#39;s neighbourhood (boolean)</span></span>
<span id="cb271-25"><a href="social-network-structure.html#cb271-25"></a>      nei &lt;-<span class="st"> </span>adjm_bool[i,]</span>
<span id="cb271-26"><a href="social-network-structure.html#cb271-26"></a>      <span class="co"># Proceed if there is at least one neighbour</span></span>
<span id="cb271-27"><a href="social-network-structure.html#cb271-27"></a>      <span class="cf">if</span>(<span class="kw">sum</span>(nei) <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>){</span>
<span id="cb271-28"><a href="social-network-structure.html#cb271-28"></a>        <span class="co"># Simple contagion for e = 1 and complex contagion for e = 2</span></span>
<span id="cb271-29"><a href="social-network-structure.html#cb271-29"></a>        <span class="cf">if</span>(<span class="kw">runif</span>(<span class="dt">n =</span> <span class="dv">1</span>, <span class="dt">min =</span> <span class="dv">0</span>, <span class="dt">max =</span> <span class="dv">1</span>) <span class="op">&lt;=</span><span class="st"> </span>(<span class="kw">sum</span>(gossip <span class="op">*</span><span class="st"> </span>nei) <span class="op">/</span><span class="st"> </span><span class="kw">length</span>(nei))<span class="op">^</span>e){</span>
<span id="cb271-30"><a href="social-network-structure.html#cb271-30"></a>          gossip[i] &lt;-<span class="st"> </span><span class="ot">TRUE</span></span>
<span id="cb271-31"><a href="social-network-structure.html#cb271-31"></a>        }</span>
<span id="cb271-32"><a href="social-network-structure.html#cb271-32"></a>      }</span>
<span id="cb271-33"><a href="social-network-structure.html#cb271-33"></a>    }</span>
<span id="cb271-34"><a href="social-network-structure.html#cb271-34"></a>    <span class="co"># Record proportion of the population with gossip</span></span>
<span id="cb271-35"><a href="social-network-structure.html#cb271-35"></a>    proportion[r] &lt;-<span class="st"> </span><span class="kw">sum</span>(gossip) <span class="op">/</span><span class="st"> </span>N</span>
<span id="cb271-36"><a href="social-network-structure.html#cb271-36"></a>    <span class="co"># Increment the round counter</span></span>
<span id="cb271-37"><a href="social-network-structure.html#cb271-37"></a>    r &lt;-<span class="st"> </span>r <span class="op">+</span><span class="st"> </span><span class="dv">1</span></span>
<span id="cb271-38"><a href="social-network-structure.html#cb271-38"></a>  }</span>
<span id="cb271-39"><a href="social-network-structure.html#cb271-39"></a>  <span class="co"># Return a tibble with simulation results</span></span>
<span id="cb271-40"><a href="social-network-structure.html#cb271-40"></a>  <span class="kw">return</span>(<span class="kw">tibble</span>(<span class="dt">time =</span> <span class="dv">1</span><span class="op">:</span>r_max, </span>
<span id="cb271-41"><a href="social-network-structure.html#cb271-41"></a>                <span class="dt">proportion =</span> proportion, </span>
<span id="cb271-42"><a href="social-network-structure.html#cb271-42"></a>                <span class="dt">time_to_max =</span> <span class="kw">which</span>(proportion <span class="op">==</span><span class="st"> </span><span class="kw">max</span>(proportion))[<span class="dv">1</span>],</span>
<span id="cb271-43"><a href="social-network-structure.html#cb271-43"></a>                <span class="dt">e =</span> e,</span>
<span id="cb271-44"><a href="social-network-structure.html#cb271-44"></a>                <span class="dt">network =</span> <span class="kw">ifelse</span>(<span class="dt">test =</span> rewire, <span class="dt">yes =</span> <span class="st">&quot;random&quot;</span>, <span class="dt">no =</span> <span class="st">&quot;clustered&quot;</span>), </span>
<span id="cb271-45"><a href="social-network-structure.html#cb271-45"></a>                <span class="dt">sim =</span> sim))</span>
<span id="cb271-46"><a href="social-network-structure.html#cb271-46"></a>}</span></code></pre></div>
<p>Note that in this function we also updated the output. Now, we return not only the proportion of individuals with gossip at each simulation round but also the time at which the maximum proportion was reached (<code>time_to_max</code>). To make plotting easier, we also return the <code>e</code> argument, whether the network was rewired (if <code>TRUE</code> we return <code>random</code>, if <code>FALSE</code> we return <code>clustered</code>), and the simulation count <code>sim</code>.</p>
<p>You might have also noticed that we turned the numeric adjacency matrix into a boolean matrix that only contains <code>TRUE</code> and <code>FALSE</code> values (using <code>adjm &gt; 0</code>). This is a little trick to speed up simulations. Instead of repeatedly asking R to identify which value in an individual’s neighbourhood is a <code>1</code>, we can get the same result instantly by turning all <code>1</code>s into <code>TRUE</code>s.</p>
<p>Let us now run the simulation for random and clustered networks, and for simple (<span class="math inline">\(e=1\)</span>) and complex (<span class="math inline">\(e=2\)</span>) contagion:</p>
<div class="sourceCode" id="cb272"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb272-1"><a href="social-network-structure.html#cb272-1"></a><span class="kw">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb272-2"><a href="social-network-structure.html#cb272-2"></a>res &lt;-<span class="st"> </span><span class="kw">bind_rows</span>(</span>
<span id="cb272-3"><a href="social-network-structure.html#cb272-3"></a>  <span class="kw">gossip_model_2</span>(<span class="dt">net =</span> net_clust, <span class="dt">rewire =</span> <span class="ot">TRUE</span>, <span class="dt">e =</span> <span class="dv">1</span>, <span class="dt">r_max =</span> <span class="dv">500</span>),</span>
<span id="cb272-4"><a href="social-network-structure.html#cb272-4"></a>  <span class="kw">gossip_model_2</span>(<span class="dt">net =</span> net_clust, <span class="dt">rewire =</span> <span class="ot">FALSE</span>, <span class="dt">e =</span> <span class="dv">1</span>, <span class="dt">r_max =</span> <span class="dv">500</span>),</span>
<span id="cb272-5"><a href="social-network-structure.html#cb272-5"></a>  <span class="kw">gossip_model_2</span>(<span class="dt">net =</span> net_clust, <span class="dt">rewire =</span> <span class="ot">TRUE</span>, <span class="dt">e =</span> <span class="dv">2</span>, <span class="dt">r_max =</span> <span class="dv">5000</span>),</span>
<span id="cb272-6"><a href="social-network-structure.html#cb272-6"></a>  <span class="kw">gossip_model_2</span>(<span class="dt">net =</span> net_clust, <span class="dt">rewire =</span> <span class="ot">FALSE</span>, <span class="dt">e =</span> <span class="dv">2</span>, <span class="dt">r_max =</span> <span class="dv">5000</span>)</span>
<span id="cb272-7"><a href="social-network-structure.html#cb272-7"></a>  )</span>
<span id="cb272-8"><a href="social-network-structure.html#cb272-8"></a></span>
<span id="cb272-9"><a href="social-network-structure.html#cb272-9"></a><span class="kw">ggplot</span>(res) <span class="op">+</span><span class="st"> </span></span>
<span id="cb272-10"><a href="social-network-structure.html#cb272-10"></a><span class="st">  </span><span class="kw">geom_line</span>(<span class="kw">aes</span>(<span class="dt">x =</span> time, <span class="dt">y =</span> proportion, <span class="dt">col =</span> network)) <span class="op">+</span><span class="st"> </span></span>
<span id="cb272-11"><a href="social-network-structure.html#cb272-11"></a><span class="st">  </span><span class="kw">facet_wrap</span>(<span class="st">&quot;e&quot;</span>, <span class="dt">labeller =</span> label_both, <span class="dt">scales =</span> <span class="st">&quot;free_x&quot;</span>) <span class="op">+</span></span>
<span id="cb272-12"><a href="social-network-structure.html#cb272-12"></a><span class="st">  </span><span class="kw">theme_bw</span>()</span></code></pre></div>
<div class="figure"><span id="fig:14-50"></span>
<img src="IBM-cultevo_files/figure-html/14-50-1.png" alt="There are no differences in the spread of gossip in clustered and random networks if it spreads based on simple contagion (left, $e=1$). However, if gossip spreads based on complex contagion (right, $e=2$), it spreads faster in clustered than in random networks." width="672" />
<p class="caption">
Figure 14.16: There are no differences in the spread of gossip in clustered and random networks if it spreads based on simple contagion (left, <span class="math inline">\(e=1\)</span>). However, if gossip spreads based on complex contagion (right, <span class="math inline">\(e=2\)</span>), it spreads faster in clustered than in random networks.
</p>
</div>
<p>As you can see, while there is no major difference in the spread of information in clustered and random networks for simple contagion (left), we find that information spreads faster in clustered networks if the transmission follows complex contagion dynamic. The reason for this is that in clustered networks an individual’s neighbours are more likely to also be connected. This increases the likelihood that the neighbours also share the same information, and, in turn, increases the individual’s exposure to this information.</p>
</div>
</div>
<div id="summary-of-the-model-13" class="section level2">
<h2><span class="header-section-number">14.6</span> Summary of the model</h2>
<p>In this chapter, we have explored individual-level effects on population-level outcomes. That is, how the structure of individual interactions affect the spread of information in a population. We have seen that both network characteristics (degree and clustering) but also the mode of information transmission (simple versus complex) can have strong effects on how efficiently information travels through a population.</p>
</div>
<div id="further-reading-7" class="section level2">
<h2><span class="header-section-number">14.7</span> Further Reading</h2>
<p>There is an increasing number of theoretical models that are looking at the effect of network characteristics on the spread of cultural traits, e.g. <span class="citation">O’Sullivan et al. (<a href="references.html#ref-osullivan_mathematical_2015" role="doc-biblioref">2015</a>)</span>. Several empirical studies with humans (<span class="citation">Hill et al. (<a href="references.html#ref-hill_hunter-gatherer_2014" role="doc-biblioref">2014</a>)</span>) and non-human animals (<span class="citation">Aplin et al. (<a href="references.html#ref-aplin_social_2012" role="doc-biblioref">2012</a>)</span>), have recorded network structures and reported on the effects of network structure on the spread of novel information. It is also interesting to ask, how the network structure itself might be the result of cultural dynamics (see e.g. <span class="citation">Smolla and Akçay (<a href="references.html#ref-smolla_cultural_2019" role="doc-biblioref">2019</a>)</span>). A good overview of relevant literature is provided in a review by <span class="citation">Derex and Mesoudi (<a href="references.html#ref-derex_cumulative_2020" role="doc-biblioref">2020</a>)</span>.</p>

</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="demography.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="group-structured-populations-and-migration.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": ["IBM-cultevo.pdf", "IBM-cultevo.epub"],
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
